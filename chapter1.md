###### <center>
    
# [컴퓨터, 컴퓨팅 사고 및 R 기초 지식 편][13]

<div style="text-align: left">
    
+ 데이터, 정보, 지식 및 지혜란 무엇인가? [그림. 1참고]
  * 데이터란 객관적인 사실 그 자체로 “의미 없는 기록”
    - 정형 데이터: 형태가 있고 연산이 가능
    - 반정형 데이터: 형태가 있으나 연산이 불가능 (예: 로그)
    - 비정형 데이터: 형태도 없고, 연산도 불가능 (예: 영문/소셜 데이터-텍스트, 영상, 음성 등)
   * 정보란 “데이터+의미”<br>
        - 데이터를 특정한 목적과 문제해결에 도움이 되도록 가공한 것<br>
   * 지식이란 “정보+가치”<br>
        - 정보를 집적하고 체계화하여 장래의 일반적인 사항에 대비해 보편성을 갖도록 한 것<br>
   * 지혜란 “지식+추론”<br>  
  ![fig1](https://user-images.githubusercontent.com/40076487/75105148-ce80a380-5654-11ea-982e-18e292c67361.png)
  ![fig2](https://user-images.githubusercontent.com/40076487/75105149-cf193a00-5654-11ea-80f6-375c54cd3e19.png)
  <div style="text-align: center"> 
    
그림. 1. 데이터, 정보, 지식 및 지혜란 무엇인가?<br>

<div style="text-align: left">
    
+ 컴퓨터, 프로그래밍 및 데이터 분석이란 무엇인가?<br>
    * 컴퓨터란? [그림. 2 및 3 참고]<br>
    

![fig3](https://user-images.githubusercontent.com/40076487/75105150-cf193a00-5654-11ea-9d7b-159e7f77f33e.png)
<center>
    
그림. 2. 컴퓨터 및 프로그래밍이란 무엇인가?

<div style="text-align: left">
    
+ 하드웨어(기계-키보드, 마우스, 본체, 모니터 등)와 소프트웨어(다양한 프로그램들)의 통칭
  * 하드웨어 란? → 사람 눈에 보이는 칩, 단자, 스위치, 키보드, 마우스, 모니터 등등
  * 소프트웨어 란? → 하드웨어에 설치된 특수 프로그램들로 종류와 목적들이 매우 다양함.
  * [참고] 일상생활에서 일반 사용자들이 사용하는 윈도우환경은하드웨어인가? 소프트웨어인가? → 윈도우 환경은 아래 그림과 같이 하드웨어와 기타 응용프로그램들 사이에서 동작하는 대표적인(매우 중요한, 주인 역할을 하는) 운영체제 소프트웨어 (Operating System Software)다. 기타 응용프로그램들은 운영체제(윈도우 환경)의 허락을 받아야 밑에 존재하는 하드웨어들을 시간에 맞춰서 예약 후 “정교하게” 사용할 수 있다. 가끔 컴퓨터가 매우 느려지거나 원하는 응용프로그램들(예: 인터넷 익스플로워, 오피스 워드, 파워포인트, 엑셀, Rstudio 등등)이 실행이 되지 않는다면 1) 운영체제를 다 지우고 새로 설치하거나, 2) 운영체제 소프트웨어 업데이트를 하거나, 3) 불필요한 기타 파일들을 지워서 메모리 및 하드의 용량을 지우거나, 4) 초기상태로 메모리를 비울 수 있도록 컴퓨터 전원을 끄고 다시 키면 대부분의 문제는 해결된다.

    
![fig5](https://user-images.githubusercontent.com/40076487/75105151-cfb1d080-5654-11ea-9b87-2f1a9edec070.png)
![fig6](https://user-images.githubusercontent.com/40076487/75105153-cfb1d080-5654-11ea-9f7a-a5f28c410e7b.png)
    
<center>
 
[기타 자세한 정보는 “시스템 프로그래밍” 개념인 별첨 1~8을 참고]

<div style="text-align: left">

+ 입력 데이터 생성, 데이터 처리/분석 및 결과 데이터 출력
    * [키보드]입력 데이터 생성 – 키보드로부터 읽어 오기, 파일로부터 읽어 오기
      
    ![fig7](https://user-images.githubusercontent.com/40076487/75105154-d04a6700-5654-11ea-9d14-f48bfc3a1bc6.jpg)
    * [본체]데이터 처리/분석 – 다양한 연산/함수들을 활용하여 특정 기능 수행 
        - 함수: 입력 값을 함수 목적에 따라 처리하여 결과 값 도출
        - 함수 문법: 함수 이름 ( )
           + 예) 덧셈 기능을 해주는 함수: add ( )
    * [모니터]데이터 출력 – 모니터 혹은 파일에 결과 출력하기
        -	함수 문법: 함수 이름 ( )
            + 예) 프린트 기능을 해주는 함수: print ( )
    * [참고] 일상생활에서 누구나 사용해 본 “계산기” 혹은 “휴대폰”도 컴퓨터인가? -> “계산기” 혹은 “휴대폰”도 “작은 컴퓨터”라고 생각할 수 있다. 하지만, “일반 컴퓨터” 처럼 다양하고 많은 기능은 많지 않고 크기도 작다. 매우 정확한 비유는 아니지만, 초보자에게 첫 단계 이해를 위해서 위와 같이 설명할 수 있다. 예를 들어서, 계산기는 오로지 “계산 기능(사칙연산 및 기타 연산 등등)”만 가진 “단말기/기계/하드웨어/작은 컴퓨터”라고 생각할 수 있다. 기타, 일반 컴퓨터처럼 다양한 기능을 가진 아듀노이, 라즈베리 파이등과 같은 “초소형 컴퓨터”도 존재한다.
     * [참고] 컴퓨터 내부 구조는 어떻게 생겼을까?  다음 그림은 일반 데스크탑(일반 컴퓨터)의 내부 구조를 보여준다. 컴퓨터 내부는 크게 다음과 같이 구성된다. 
      ![fig8](https://user-images.githubusercontent.com/40076487/75105155-d04a6700-5654-11ea-906f-8ac61cee9286.png)
      ![fig9](https://user-images.githubusercontent.com/40076487/75105156-d0e2fd80-5654-11ea-8876-36600f18e714.png)
+ ① 사용자가 컴퓨터에 입력할 수 있는 마우스 및 키보드,<br> 
  ② 컴퓨터 전원을 꺼도 추후 사용자가 열어보고 싶은 파일 및 데이터를 저장하는 하드 디스크 (disk),<br> 
  ③ 사람의 뇌(머리)에서 모든 총괄을 수행하듯 컴퓨터에서 중심적인 역할을 수행하는 CPU (Central Processing Unit),<br> 
  ④ 컴퓨터 중심인 CPU가 기계 명령어 해석을 위해 필요로 하는 정보를 저장하는 컴퓨터 메모리(memory), <br>
  ⑤ CPU가 기계 명령어 수행 시 연산/계산 부분을 수행하기 위해 활용하는 ALU (Arithmetic Logic Unit)<br>
  ⑥ 컴퓨터 실행파일 수행 후, 사용자에게 결과를 보여주기 위한 출력 파트(monitor) 등등 <br>


  [하드웨어 및 소프트웨어 실행의 구체적인 과정]
  기타, 아래 그림과 같이 사용자가 컴퓨터 전원을 켜고 간단한 프로그램을 작성 후 실행되는데 필요로 하는 구체적인 과정은 다음과 같다.<br>
  ![fig10](https://user-images.githubusercontent.com/40076487/75105157-d17b9400-5654-11ea-8a56-79aae44e3450.png)
  ① 사용자(프로그래머)가 마우스 혹은 키보드를 이용해서 데이터 입력 및 프로그래밍을 수행하면 해당 명령어는 기계어 변환되어 컴퓨터 메모리에 규칙적으로 저장된다. 해당 프로그램을 기계어로 변환하는 컴파일 과정에서 해당 프로그램 실행 파일은 디스크에 저장된다. 결과, 사용자가 해당 실행 파일을 실행하면 컴퓨터는 사용자 모니터에 보이기 바로 전 단계로 실행파일을 실행하기 위해 해당 부분이 이미 디스크에 있는지 찾는다. 만약, 디스크에 없으면 컴퓨터 메모리에 다시 요청 한다. 아래 그림은 해당 과정을 상세하게 보여준다. [기타 자세한 정보는 별첨 9 및 10을 참고]<br>
  ![fig11](https://user-images.githubusercontent.com/40076487/75105158-d17b9400-5654-11ea-8653-d7ed929c5d84.png)
  ② 사람의 뇌(머리)에서 모든 총괄을 수행하듯 컴퓨터에서 중심부는 CPU (Central Processing Unit)이다. CPU는 컴퓨터 메모리에 탑재된 명령어들을 순차적으로 수행하면서 연산이 필요한 부분은 ALU (Arithmetic Logic Unit)의 도움을 받아 처리하게 된다. 예를 들어, 프로그래머가 작성한 코드가 덧셈 계산을 수행하는 내용 이였다면 기계 명령어로 변환 되어 컴퓨터 메모리에 저장되어있는 명령어를 CPU가 한 줄 한 줄 읽고 수행하다가 계산 부분이라고 판단되면 그 부분은 ALU에 보내서 답을 얻는 것이다. [기타 자세한 정보는 별첨 9 및 10을 참고]<br>
  ③ 앞서 언급했듯이, 프로그래머는 키보드 상의 숫자, 알파벳 및 특수문자등을 이용해서 프로그래밍을 하게 된다. 하지만, 컴퓨터 기계 내부에서는 아래 그림과 같이 “컴파일러”라고 하는 또 다른 응용 프로그램을 통해서 컴퓨터 명령어 문법 에러를 검출하고 기계 명령어(기계어: 기계가 이해할 수 있는 또 다른 언어, 비트-bit)로 변환시켜서 저장하게 된다.
  ![fig12](https://user-images.githubusercontent.com/40076487/75105159-d2142a80-5654-11ea-87a3-48ce4b5c2386.png)
  즉, 프로그래머가 작성하는 프로그래밍 언어를 high-level programming language라고 하고 기계가 이해하는 프로그래밍 언어를 low-level programming language라고 한다. 위처럼 크게 두 가지 언어로 나뉜 이유는 프로그래머는 보통 사람이기 때문에 프로그래밍을 쉽게 이해할 수 있는 키보드 상의 숫자, 알파벳 및 특수문자 등을 사용할 수 있도록 하는 것이고, 컴퓨터 기계는 기계 특성상, 아래 그림과 같이 내부적으로 스위치, 메모리(램), 하드, CPU, Cache등과 같은 스위치 기반의 하드웨어로 구성되기 때문에 비트(bit)단위의 바이너리 데이터로 되어 있기 때문이다. 말 그대로 컴퓨터 기계는 기계이기 때문에 “있다(on)” 혹은 “없다(off)”로만 인식할 수 있는 것이다.  [기타 자세한 정보는 별첨 11을 참고]
  ![fig13](https://user-images.githubusercontent.com/40076487/75105160-d2142a80-5654-11ea-8a1c-384b5e65b572.png)
  다음 그림은 앞서 설명한 바와 같이 프로그래머가 키보드를 사용해서 프로그래밍하면 해당 명령어가 기계어로 변환되어 본체 메모리에 저장되고 CPU에서 계산되는 과정을 한 번에 보여주는 그림이다.<br>
  ![fig14](https://user-images.githubusercontent.com/40076487/75105161-d2acc100-5654-11ea-8c95-12fc24554861.png)
  ④ 향후 우리가 배울 R 프로그래밍 언어는 인터프리터 언어라고 볼 수 있다. R은 다른 프로그래밍 언어들에 비해서 프로그래밍이 쉬운 편이다. 하지만, 내부적으로는 결국 c언어 등의 컴파일러 기반의 언어들을 사용한다. 결과, 향후 우리가 직접 배우게 될 R언어를 사용하기 전에 컴퓨터의 기본 원리와 컴파일러 기반의 일반 프로그래밍의 원리를 함께 설명했다. 참고로, 위 그림들에서 확장자가 (.c)인 파일(예: hello.c)은 c언어라는 프로그래밍 언어로 작성 후 저장한 파일을 의미한다. 향후, 우리가 배울 R프로그래밍 언어로 프로그래밍 후 작성한 파일은 확장자가 (.R)이다. 아래 그림과 표는 인터프리터와 컴파일러의 차이점을 보여준다.<br>
  ![fig15](https://user-images.githubusercontent.com/40076487/75105162-d2acc100-5654-11ea-9e05-ab43825fa961.png)
  
  |-|컴파일러|인터프리터|
  |:---|:---|:---|
  |방식(번역단위)|프로그램 전체 번역|실행되는 줄(행/라인) 단위 번역 (결과, 번역 과정  이 간단하고 대화형 언어에 유리함)|
  |실행 속도|①첫 실행- 느림(∵ 프로그램 전체 번역)<br>②두번째부터 실행-빠름 (∵ 한번 “번역/컴파일”한 후에 목적 파일을 이용해서 매번 빠른 시간 내에 전체 실행 가능)|①	간단 소스 실행- 빠름 <br>②긴 소스 실행-느림|
  |번역 속도|-|반복 문이 많은 경우 매 반복 때마다 번역해야 함 (즉, 실행할 때마다 매번 기계어로 바꾸는 과정을 다시 수행해야하므로 항상 “번역가(인터프리터)”가 대기 해야함.|
  |용량|큰 기억장치 필요|작은 기억장치 필요|
  |프로그램 소스 유지보수|소스의 일부분을 수정해도 전체 소스를 재 컴파일해야함|수정한 부분만 수정 후 해당 부분만 선택해서 실행하면 빠름.|
  |출력물|목적 코드 (목적 코드를 링커가 링킹 후 실행 프로그램으로 실행)|즉시 코드 (즉시 실행됨)|

    <br>
+ 프로그래밍
  * “인간”이 “컴퓨터”가 이해할 수 있는 문법에 맞춰서 명령어를 작성하는 것 [그림. 3참고]
  * 그림. 3은 사람들이 흔히 사용하는 윈도우 환경에서 RStudio라는 프로그램을 따로 설치하고 sample.R이라는 파일을 만들고 R이라는 언어의 문법에 맞춰서 두 변수의 합을 출력해서 모니터로 확인하는 예제를 프로그래밍 한 것. 각 줄을 명령어라고 하고 각 명령어는 각 언어의 문법에 맞춰서 프로그래밍되서 컴파일 후 실행해야 에러가 뜨지 않음. 
  * [참고] 프로그래밍은 윈도우 운영체제 환경에서 RStudio프로그램을 설치하고 R프로그래밍만 가능할까?  기타 다른 환경(예: 윈도우 환경인지, 리눅스 환경인지, 기타 운영체제 환경인지 등등)과 다른 프로그래밍 언어들(예: c언어 프로그래밍, c++언어 프로그래밍, 자바 프로그래밍, 파이썬 프로그래밍 등등)들을 어떤 식으로 조합해서 사용할 지는 프로그램의 목적, 비용, 성능, 프로그래머의 친숙도 등의 기타 이유로 다양할 수 있다. 결과, 어떤 조합으로 프로그래밍해서 문제를 해결하는 지에 따라서 프로그래머가 겪는/알아야하는 정보도 상이하고 다양하다. [기타 자세한 정보는 별첨 12를 참고]<br>
 ![fig16](https://user-images.githubusercontent.com/40076487/75105163-d3455780-5654-11ea-9709-5494a3275ef4.png)
  <center> 
    
   그림. 3. 컴퓨터 프로그래밍이란 무엇인가?
    
 <div style="text-align: left">
    
 + 컴퓨터 명령어란 컴퓨터 기계가 이해할 수 있는 언어로 데이터, 변수 및 함수로 구성. 변수는 데이터를 담는 그릇이고 함수는 중고등학교때 배운 독립 변수에 따른 종속변수 개념과 동일 [그림. 4 참고]<br>
+ 프로그래밍에서 함수의 개수는 무한 개가 존재하며 기존에 존재하는 표준함수들과 프로그래머가 정의하는 사용자 정의 함수가 존재
   * 함수(입력 함수): scan( ), readline( ), readLines( ) 등등
   * 표준 함수(출력 함수): print( ), cat( ), write( ) 등등
   * 사용자정의함수(짝수 혹은 홀수만 선별해서 더해주는 함수, odd_add( ) 혹은 even_add( ) 등등)<br>
+ [참고] 어떤 프로그래밍 언어로 프로그래밍하든 프로그래밍은 변수와 함수를 잘 사용하고 사용자 정의 함수를 잘 정의할 수 있으면 90%이상은 이해한 것입니다. 함수는 함수 안으로 들어갈 수 있는 입력 인자(Arguments)들의 개수 및 종류/타입에 따라서 매우 다양하게 활용될 수 있습니다. 각 함수의 사용법은 암기하는 것은 아니고 수업 교과과정 및 독학 등을 통해서 한번 접한 뒤 융통성 있게 책, 인터넷 등의 매뉴얼을 그때 그때 찾아보면서 사용하는 것이 효율적입니다. 다만, 전혀 모르는 상태에서는 어떤 책을 인터넷 어디를 어떻게 찾고 활용해야 할지 모르기 때문에 정규수업을 통해서 라도 중요하고도 기본적인 지식은 배워 놔야 하는 것입니다.<br>
![fig17](https://user-images.githubusercontent.com/40076487/75105164-d3ddee00-5654-11ea-9af4-635a4dec110d.png)
<center> 
    
   그림. 4. 함수란 무엇인가?
    
 <div style="text-align: left">
    
+ 변수와 함수의 작동 예시 (사람 해결 vs. 컴퓨터 해결) [그림. 5 참고]
  * 사람은 특정 문제를 해결하기 위해서 순식간에 머릿속으로 자연스럽게 해결방법을 찾곤 한다. 예를 들어서, 학생들은 수업1과 수업2 사이 공간 시간에 무엇을 하면 제일 효율적일지 끈임 없이 생각하곤 한다. 만약 수업1을 듣고있으면서 수업2의 숙제 못한 것을 인지했다면 대부분의 학생들은 공강 시간에 수업2의 숙제를 할 것이다. 하지만 만약 숙제가 없다면 미리 점심을 먹어 놓는 것이 좋은지, 다른 팀 프로젝트 과제 미팅을 진행하는게 좋을지 및 이성친구를 잠시 만날지 등등 다양한 경우로 생각할 것이다. 
  *  컴퓨터 프로그래밍도 이와 같다. 다만, 사람 머릿속으로 생각하고 해결해야하는 것을 컴퓨터가 대신 해주는 것이다. 따라서, 컴퓨터가 이해할 수 있는 기계 명령어 규칙과 문법을 수업시간에 배우고 이를 고려해서 프로그래밍을 해야하는 것이다. 즉, 기계 명령어는 크게 데이터, 변수 및 함수로 구성된다.
![fig18](https://user-images.githubusercontent.com/40076487/75105165-d3ddee00-5654-11ea-8953-0ecbb24ba7b8.png)
<center> 
    
   그림. 5. 함수 사용의 예
    
 <div style="text-align: left">

+ [참고] 어렸을 적 즐겨했던 장난감 레고 vs. 프로그래밍? 은 관련이 있을까요? 앞서 언급했듯이 프로그래밍은 “함수, 예약어, 변수, 데이터, 모듈＂들의 조합입니다! 따라서, 아래 그림과 같이 우리가 어렸을 때 스스로 레고 조각으로 다양한 작품을 만들 수 있듯이 “함수, 예약어, 변수, 데이터, 모듈＂를 잘 조합해서 훌륭한 상품(프로그램)을 만들 수 있습니다!! 즉, 저는 레고 조각을 프로그램을 구성하는 각 함수, 예약어, 변수, 데이터 및 모듈로 비교하곤 합니다.<br>
+ 어렸을 때 같은 레고 조각들이지만 어떤 친구는 자동차와 비행기를 만들고, 또 다른 친구들은 잔디밭이나 성, 집 등을 만들곤 합니다. 이는 각 학생들의 관심사, 배경지식 및 목표 등이 달라서 그렇습니다.^^ 프로그래밍도 마찬가지입니다. 각 프로그래밍 언어에서 제공하는 함수의 종류, 예약어의 종류, 모듈들의 종류 등은 동일합니다. 하지만 어떤 프로그래머들은 아이폰 앱을 개발하기도 하고 다른 프로그래머들은 초소형 컴퓨터와 결합해서 눈에 보이는 상품 등을 만들기도 합니다. 즉!!, 프로그래밍은 무에서 유를 창조할 수 있는 멋진 직업! 멋진 능력! 기술력 중 하나! 하나로, (비)전공자 학생들이 필수적으로 배우고 졸업 전&후 취업, 인턴 및 직업 등으로 연결 지어야 /하는 중요한 분야입니다. 잠시 여담으로 현재 모든 대학가에서는 전공에 불문하고 모든 대학생 1-2학년 학생들이 컴퓨터와 인간/컴퓨터와 프로그래밍등의 과목들을 교양필수 과목으로 듣고 있습니다. 이는^^ 세상은 급변하고 있고 이에 걸맞는 준비를 해야만, 경쟁력 있는 전문가가 될 수 있다는 증거입니다.<br>
     
![fig19](https://user-images.githubusercontent.com/40076487/75105166-d4768480-5654-11ea-8e24-d6e68b5d732c.png)
    
+ [참고] 현재, 대학교 비 전공자는 물론 유아 코딩부터 초중고 학생들까지 프로그래밍을 필수 교과목으로 지정해서 창의력을 키우고 있다고 합니다. 대학 입학 전 학생들은 어떤 프로그래밍을 할 수 있고 왜 이런 현상이 나타난 것일까요?  모두 아시겠지만 2018년부터 초중고 교과과정에 프로그래밍 과목은 필수! 현재, 대학가에서는 영문학과, 사학과 및 의대와 법대 까지… 비전공자 학생들에게도 소프트웨어 프로그래밍 교육 열풍이 불고 있습니다. 교양 필수 과목으로 지정되었기 때문에 졸업 필수 요건 중에 하나인 거죠 결과, 이쯤에서^^ 저희의 최대 관심사 중에 하나인 “코딩! 비전공자코딩! 정말 중요하고, 사고력과 논리력을 키워줄까? “에 대해서 논의해보고자 합니다. ^^ <br>
+ 누구나 한번쯤을 들어보셨을~~ Facebook의 창업자 마크저커버그, IBM의 빌게이츠, Apple사의 스티브잡스 및 오바마 대통령… 모두 한결같이^^ 유아 때부터 프로그래밍의 중요성을 강조하고 있습니다. 그 이유는 기존의 획실적이고 단일화된 사고를 탈피하여 자유롭게 상상하고 손으로 만들고 결과를 눈으로 볼 수 있는 최고의 방법이 “프로그래밍^^”이라고 생각하기 때문이죠. 실제로, 미국 및 유럽 등의 대표적인 외국 유아기관, 초중고 및 대학에서는 전공, 성별 및 나이를 불문하고 모든 사람들이 아래 그림과 같은 리틀비츠, 아듀이노 및 라즈베리파이 등의 초소형 컴퓨터 기능을 탑재한 다양한 장난감으로 프로그래밍 교육을 수행하고 있습니다. <br>
 
  ![fig20_1](https://user-images.githubusercontent.com/40076487/75105641-1efa0000-5659-11ea-842d-b08c7a991a1d.png)
  ![fig20_2](https://user-images.githubusercontent.com/40076487/75105640-1dc8d300-5659-11ea-8f33-d9755756865a.png)
 
+ 	조금 더 구체적으로~~ 정규 수업을 받기 전, 아이들이 직접 만들어 보거나 경험할 수 있는 코딩 장난감들은 어떤 것들이 있을까요? 기존의 레고와 달리 코딩 기능이 탑재된 레고 조각들은 경우의 수가 더욱 다양한 기능을 가지고 있습니다. 전원이 공급되면 다양한 경로로 움직이는 기능을 가진 레고, 불빛을 켜고 끌 수 있는 기능을 가진 레고, 다양한 소리를 발생시키는 레고 및 물건을 집고 다양한 속도로 이동 시킬 수 있는 레고 등 다양합니다. 결과, 나이에 상관없이 유아 때부터 장난감 사용법을 익히듯이 버튼 조작으로 초보 프로그래밍을 배우게 되면 유아가 스스로 만들고 싶은 상상의 환경을 창의적으로 만들 수 있는 것입니다. 학년이 올라가면서 학생들은 점점 장난감에서 더욱 지능화된 장난감, 드론(Drone) 및 무인 자동차(Automated Vehicular Network) 등과 같은 초소형 단말기는 물론 컴퓨터 기계에 직접 기계어로 코딩해서 이 세상에 유일한 창작품을 만들고 싶은 욕구가 생길 수 있겠죠?  물론 개인차가 있을 수 있지만^^ 프로그래밍을 하면서 원하는 데로 결과가 나왔을 때 성취감 및 자신감은 융합적 창의적인 인재가 되는데 큰 도움이 될 수 있다고 생각됩니다^^ <br>
+ 가정 내에서 쉽게 접하실 수 있는 “로봇 청소기” 또한 프로그래밍의 창작품이라고 볼 수 있겠습니다. 처음엔 정교함이 떨어져서 신발 대 혹은 화장실 등과 같은 장소에 로봇청소기가 작동 오류로 멈춰있는 경우도 있었지만 기술은 점점 발전하여 프로그래머들은 로봇 청소기가 사람처럼 “눈도 있고 손도 있고 생각하는 머리도 있도록^^”, 즉 사람처럼 논리적으로 생각할 수 있도록 더욱 인공 지능화 했습니다! <br>
+ 4차 산업혁명을 앞두고 있는 요즈음, 누구나 창의력^^을 키워야 한다고 말하곤 합니다. 이때까지는 미술, 음악 및 체육 등과 같은 예체능 과목으로만 가능했다고 생각할 수 있지만, 융합 및 창의적인 인재 양성이 강조되고, 과학, 기술, 공학, 예술 및 수학의 중요성을 강조하는 STEAM (Science, Technology, Engineering, the Art, Mathematics)교육을 가까이에서 실천하고 미래를 대비할 수 있는 제일 쉬운 첫걸음은!! “코딩! 비전공자코딩! “ 이라고 생각됩니다^^ <br>

 + 데이터 분석
![fig21](https://user-images.githubusercontent.com/40076487/75105167-d50f1b00-5654-11ea-9fc7-9054d10c730e.png)
 
  * 위 그림과 같이 키보드에서 실시간으로 발생하는 데이터 셋 혹은 컴퓨터 파일 및 인터넷 등에 내장된 데이터셋등을 컴퓨터가 분석하여 의미 있는 결과 도출
  *  사람이 직관적으로 알 수 없는 미래를 예측 등등
  *  예) 다양한 등장인물이 등장하는 특정 이야기에서 각 등장인물들의 만남 횟수 등의 데이터를 분석하여 “주인공”과 “엑스트라” 구분
  *  예) 유투브에 올라온 다양한 동영상들 중에서 조회수, 좋아요의 수, 댓글의 개수, 평점의 평균 등과 같은 통계적인 데이터들을 분석해서 인지도 높은 동영상 추출
  * 예) 스티브잡스, 오바마 대통령, 트럼프 대통령등의 유명인사들의 연설문 데이터를 분석하여 핵심 키워드(많이 사용되는 키워드) 추출 후 경향성 분석등등   
  * [참고] 사람이 직접 생각해서 문제를 풀면 되는데 왜 굳이 컴퓨터 명령어 작성 문법을 배우고 컴퓨터에 코딩/프로그래밍 해서 문제를 풀어야하나요?  이 세상의 대부분의 문제는 사람이 빠른 시간 내에 생각 후 풀 수 있는 문제들이 대부분입니다. 하지만, 사람은 1개의 머리를 가지고 있고, 저녁시간에는 잠도 자야 하고 동시에 생각할 수 있는 경우의 수가 한정적 입니다. 반면, 컴퓨터는 기계이기 때문에 돈을 많이 투자할 수 있다면 동시에 생각할 수 있는 중심부(CPU/GPU: Processing Unit)를 여러 개 작동시킬 수 있으며, 24시간 가동시킬 수 있습니다. 또한, 처리해야하는 데이터 사이즈가 아무리 커도 (예: 빅 데이터) 여러 대의 컴퓨터들을 동시에 사용하거나 1개의 컴퓨터를 사용한다고 해도 앞서 언급한것처럼 여러 객의 CPU/GPU를 가동시키면 되기 때문에 문법 오류가 없는 프로그래밍만 잘 작성한다면^^ 시간 및 최적의 답을 찾는데 더 효율적이라고 할 수온라인 데이터 있습니다. 최근, “빅 데이터”라는 용어를 많이 들어봤을 것입니다. 인터넷 및 휴대폰 단말기의 사용량 등이 급격하게 증가하면서 를 무한대로 인터넷 서버, 로컬 컴퓨터 메모리 및 컴퓨터 파일 등의 형태로 기하급수적으로 쌓이고 있습니다. 빅 데이터의 분야 및 종류는 무궁무진하며 해당 데이터를 잘 분석한다면 각 분야에서 미래 가치 서비스 창조 및 마케팅 분야 등으로 활용될 수 있기 때문에 국가, 기업체, 병원, 연구소 및 학교 등 모든 나라 및 기관에서 큰 관심을 가지고 “질 좋은 빅 데이터 수집 및 분석”에 큰 관심을 보이는 것입니다. 따라서, 이런 빅 데이터를 분석할 수 있는 프로그래밍 명령어 문법과 방법론을 익힌다는 것은 졸업 후 여러분의 기술 및 능력 중 전문기술 한 개를 확실하게 키우는 지름길 입니다.^^ 


 <div style="text-align: left">
     
+ 데이터 마이닝과 텍스트 마이닝은 무엇인가?
  * 데이터 마이닝
    - 대규모 빅 데이터에서 가치 있는/의미 있는 정보를 추출하는 기술
      + 빅 데이터의 타입은 다양하게 포함 가능
    - 사람이 예측할 수 없는 의미 있는 경향과 규칙까지 발견하기 위해서 대량의 빅 데이터로부터 자동화 혹은 반자동화 도구를 활용해 탐색하고 분석하는 과정<br>
+ 텍스트 마이닝
  * 대규모의 텍스트 문서에서 의미 있는 정보를 추출하는 기술
  * 비정형 데이터(글자/텍스트)를 정형화된 데이터(수치)로 바꾸어 분석하는 방법
  * 텍스트 덩어리 안에서 단어들을 분해해 단어의 출현 빈도나 단어들 간의 관계성을 파악하여 의미 있는 정보를 추출해내는 기술
  * 정보 검색, 데이터 마이닝, 기계 학습(machine learning), 통계학, 컴퓨터 언어학(computational linguistics) 및 컴퓨터 공학 등이 결합된 분야
  * 특히 분석 대상이 형태가 일정하지 않고 다루기 힘든 비정형 데이터이므로 인간의 언어를 컴퓨터가 인식해 처리하는 자연어 처리(NLP, natural language processing) 방법과 관련이 깊음<br>
     
  ![fig22](https://user-images.githubusercontent.com/40076487/75105168-d50f1b00-5654-11ea-86f7-0d214f43586f.png)
  ![fig23](https://user-images.githubusercontent.com/40076487/75105169-d5a7b180-5654-11ea-9fdc-c0afc612df20.png)

  * 텍스트 마이닝 예시 (R코드 샘플)
  ![fig24](https://user-images.githubusercontent.com/40076487/75105170-d6404800-5654-11ea-9aa1-d44444c434be.png)
+ 영어/중국어/일본어 등과 같은 일반 언어들과 컴퓨터프로그래밍은 언어는 어떻게 다를까?
  * 일반 언어: “인간”과 “인간”이 소통하는 수단 (예: 다양한 언어들이 존재)
  * 컴퓨터 프로그래밍 언어: “컴퓨터”와 “인간”이 소통하는 수단 (예: 다양한 컴퓨터 언어들이 존재) [그림. 6 참고]<br>

![fig25](https://user-images.githubusercontent.com/40076487/75105171-d6404800-5654-11ea-96c7-dff86254f288.png)
     
<center> 
    
   그림. 6.  일반 언어와 컴퓨터 프로그래밍 언어의 차이점이란 무엇인가?
    
 <div style="text-align: left">
    
+ 각 언어에 문법이 존재하듯이 컴퓨터 프로그래밍언어도 문법(규칙)이 존재할까?
  * 각 언어에 “문법”이 존재해야 사람들이 규칙 있게 이야기하듯, 컴퓨터 프로그래밍도 문법에 맞도록 컴퓨터에 코딩을 해야 컴퓨터가 이해할 수 있음.
  * 컴퓨터 코딩이란? 컴퓨터 기계가 이해할 수 있도록 기계 명령어를 문법에 맞게 프로그래머가 작성하는 것
  * 기계 명령어는? 데이터, 변수 및 함수로 구성 [그림. 3 및 6 참고]<br>
+ 컴퓨터 프로그래밍 언어는 몇가지나 될까?
  * 오래전부터 매우 다양한 프로그래밍 언어들이 존재함. [그림. 7참고]<br>
     
  ![fig26](https://user-images.githubusercontent.com/40076487/75105676-ac3d5480-5659-11ea-86d5-5e2dcd1bac02.png)  
  ![fig27](https://user-images.githubusercontent.com/40076487/75105675-aba4be00-5659-11ea-9c1d-21fb56da2341.png)
     
  <center> 
    
   그림. 7.  컴푸터 프로그래밍 언어는 몇가지나 될까?
    
 <div style="text-align: left">
 
+ 그 중에 R이란 프로그래밍 언어를 선택한 이유는 뭘까?
  * 무료, 큰 입력 데이터 생성, 처리/분석 및 출력까지 한번에 효율적으로 할 수 있음
    - R기반 시스템 운영 거대 기업들<br>
![fig28](https://user-images.githubusercontent.com/40076487/75105172-d6d8de80-5654-11ea-978c-9e542392d6eb.png)


+ 특히, 빅 데이터 시각화에 매우 능함. 다음과 같이 다양한 각도에서 그래프를 생성할 수 있음. 
  * 예) 데이터 원본: https://grouplens.org/datasets/movielens/1m/
  * 예) R 코드 원본: http://popeye.snu.ac.kr/~hyoh/courses/R/movielens.R
    - MovieLens 1M Dataset
      + 6,000명의 사용자, 4,000개의 영화 및 1,000,210개의 평점 (빅 데이터)에 대해서 데이터 특성을 한눈에 빠르게 가시화해보고 비교 및 분석할 수 있음.
        * 예) 영화 빅 데이터의 장르는 20개 정도이며, 그 중 drama와 comedy시청률이 제일 높음.
        * 예) 영화를 시청하는 나이 대는 20살~ 40살이 대부분이고, 여성보다는 남성의 비율이 좀 더 높은 경향을 가짐.<br>
 ![fig29](https://user-images.githubusercontent.com/40076487/75105173-d7717500-5654-11ea-8e77-69676188de20.png)
 ![fig30](https://user-images.githubusercontent.com/40076487/75105174-d7717500-5654-11ea-89f5-482563439b64.png)
 ![fig31](https://user-images.githubusercontent.com/40076487/75105175-d80a0b80-5654-11ea-8491-d1cb1ae38615.png)
 ![fig32](https://user-images.githubusercontent.com/40076487/75105176-d8a2a200-5654-11ea-8f82-8438af67fc09.png)
 ![fig33](https://user-images.githubusercontent.com/40076487/75105177-d8a2a200-5654-11ea-9315-2cb42e4a3e06.png)
 ![fig34](https://user-images.githubusercontent.com/40076487/75105178-d93b3880-5654-11ea-9e97-b22a02bc09a8.png)
 ![fig35](https://user-images.githubusercontent.com/40076487/75105179-d93b3880-5654-11ea-9a3d-e79d72167ba9.png)
 ![fig36](https://user-images.githubusercontent.com/40076487/75105180-d9d3cf00-5654-11ea-80dc-07a83929b9de.png)
+ R을 효율적으로 사용하기 위한 환경 (RStudio)에서 짧은 질문과 긴 질문을 해볼까?
  * RStudio란?<br>
![fig37](https://user-images.githubusercontent.com/40076487/75105181-d9d3cf00-5654-11ea-8e8d-2907a4d34f31.png)
![fig38](https://user-images.githubusercontent.com/40076487/75105182-da6c6580-5654-11ea-9f3e-13567b8d6fb9.png)

+ 콘솔(Console)
  * 단발적인 짧은 질문들 [그림. 8참고]
  * 명령어 입력 후 엔터(enter)를 누르면 해당 결과 확인 가능<br>![fig39](https://user-images.githubusercontent.com/40076487/75105183-db04fc00-5654-11ea-8723-8c55bb2933d9.png)

<center> 
    
   그림. 8.  RStudio의 콘솔화면에서 일시적인 짧은 질문(코딩/명령어 입력) 하기
    
 <div style="text-align: left">

+ 소스 창(Source)
  * 장기적인 (긴) 질문들 [그림. 9참고]
  * 소스 창에서 파일 작성 후 파일을 저장 하면 (*.R), RStudio는 물론 컴퓨터 전원을 껐다가 다시 켜도 (즉, 다음에 다시 사용할 때에도) 해당 파일(*.R)을 검색해서 열면 되기 때문에 효율적 [아래 비교 테이블 확인]<br>
  
|-|콘솔(Console)|소스 창(Source)|
|:---|:---|:---|
|목적|짧은 질문|긴 질문|
|실행|엔터(enter)|키보드 Ctrl+Shift+S 혹은 Ctrl+Shift+Enter|
|장점| 실시간 응답| RStudio랑 컴퓨터를 꺼도 추후 해당 파일을 찾아서 실행시킬 수 있음|
     
 <br>    
![fig40](https://user-images.githubusercontent.com/40076487/75105184-db04fc00-5654-11ea-9e0b-a419dcb92e59.png) 

     
<center>    
   그림. 9.  RStudio의 소스 창에서 영구적인 “상대적으로 긴 질문(코딩/명령어 입력)” 하기
    
 <div style="text-align: left">
    
 + 프로젝트 생성 후 소스에 코딩 및 실행  
![fig41](https://user-images.githubusercontent.com/40076487/75105185-db9d9280-5654-11ea-9bb2-8670501086d5.png)
![fig42](https://user-images.githubusercontent.com/40076487/75105186-db9d9280-5654-11ea-9b89-b75463f9f4bc.png)
![fig43](https://user-images.githubusercontent.com/40076487/75105187-dc362900-5654-11ea-9ea4-996e8da633c4.png)


+ Jupyter환경이란?
  * Jupyter Notebook은 데이터 과학 분야에서 인기 있는 파이썬, R  등 대략 40가지 이상의 프로그래밍 언어를 지원. 
  * 실시간으로 인터렉티브하게 데이터 클리닝, 변형, 시각화 및 설명을 위한 텍스트 문서등을 만들고 쉽게 공유할 수 있기 때문에 의미가 큼.<br>
+ Jupyter의 역사
* Python(커맨드라인 인터페이스) REPL: Read Eval Print Loop (코드를 한줄씩 읽고 처리 후 결과 출력)의 아이디어가 의미가 있음  IPython 0.0.1~ (2001년, Python기본 RELP의 확장) IPython 0.12 (2011년, 웹 기반 실행 인터페이스)  IPython Notebook(2013, 2014년, 한계점: 1개의 커널만 접속되고, 다른 커널 접속하려면 서버를 다시 켜야함), IPython 3.0(Jyputer라는 이름이 등장, 여러 개의 커널 중에서 선택해서 사용할 수 있게 됨)  IPython 4.0과 Jupyter Notebook 4.0 (범용적 REPL 프레임워크) 으로 분리됨<br>
+ Jyputer notebook에서 R 사용방법
  * R을 사용하려면 Jyputer notebook에 R커널을 설치해야함<br>
  ![fig44](https://user-images.githubusercontent.com/40076487/75105188-dc362900-5654-11ea-8a4a-6563955690b7.png)
  ![fig45](https://user-images.githubusercontent.com/40076487/75105189-dccebf80-5654-11ea-8e78-73c1bf46c807.png)
  ![fig46](https://user-images.githubusercontent.com/40076487/75105190-dd675600-5654-11ea-9ed1-72f70aaa1960.png)
  ![fig47](https://user-images.githubusercontent.com/40076487/75105191-dd675600-5654-11ea-82d4-33b1a09bd857.png)
  ![fig48](https://user-images.githubusercontent.com/40076487/75105192-ddffec80-5654-11ea-967f-a6e1813282f9.png)

 
+ 구글에서 “Jupyter환경에서 R수행할 수 있는 방안”들을 검색 후 다음 그림들과 같이 환경 세팅<br>
![fig49](https://user-images.githubusercontent.com/40076487/75105193-ddffec80-5654-11ea-933b-91883bb01683.png)
Python3는 물론이고 R이 수행할 수 있는 환경이 된 것을 알 수 있음.
![fig50](https://user-images.githubusercontent.com/40076487/75105194-de988300-5654-11ea-8a91-024e8e2d14e1.png)
인터렉티브한 환경이 가능함을 알 수 있음.
![fig51](https://user-images.githubusercontent.com/40076487/75105196-de988300-5654-11ea-86c6-5bf48db5ea0f.png)
Running메뉴에서 현재 수행중인 터미널들의 유무를 확인할 수 있음.
![fig52](https://user-images.githubusercontent.com/40076487/75105197-df311980-5654-11ea-8beb-8695865b3d5d.png)
작업이 수행중인 (Running상태) Untitled.ipynb가 생성되고 관련 정보가 확인됨을 알 수 있음
![fig53](https://user-images.githubusercontent.com/40076487/75105198-df311980-5654-11ea-87db-490fd3971ec7.png)
![fig54](https://user-images.githubusercontent.com/40076487/75105200-dfc9b000-5654-11ea-82b7-8f3f42555afb.png)
Logout버튼 옆에 R이라는 로고가 뜨는 것을 확인할 수 있음<br>
생성된 Jupyter 프로젝트의 이름을 설정할 수 있음.<br>
Last checkpoint시간 및 autosaved유무를 알 수 있음.<br>
인터렉티브하게 사용자가 작성&수정 등을 편리하게 할 수 있음을 알 수 있음.<br>
![fig55](https://user-images.githubusercontent.com/40076487/75105201-dfc9b000-5654-11ea-9203-8fe9ed37fce8.png)
![fig56](https://user-images.githubusercontent.com/40076487/75105202-e0624680-5654-11ea-998a-712976de8a59.png)
![fig57](https://user-images.githubusercontent.com/40076487/75105203-e0fadd00-5654-11ea-99e0-c2b16e493591.png)
![fig58](https://user-images.githubusercontent.com/40076487/75105204-e0fadd00-5654-11ea-82fa-81fb28ab1352.png)
![fig59](https://user-images.githubusercontent.com/40076487/75105206-e1937380-5654-11ea-9880-ee0629da892b.png)
![fig60](https://user-images.githubusercontent.com/40076487/75105207-e1937380-5654-11ea-896a-206f59923dde.png)
![fig61](https://user-images.githubusercontent.com/40076487/75105208-e22c0a00-5654-11ea-86c5-14b6a3ffdcb8.png)
![fig62](https://user-images.githubusercontent.com/40076487/75105209-e22c0a00-5654-11ea-91ff-ed942ca8227b.png)
![fig63](https://user-images.githubusercontent.com/40076487/75105210-e2c4a080-5654-11ea-8e45-7d4dd964abe6.png))
작업 후, 저장은 아래 그림과 같이 다양하게 할 수 있음. (예: 파일 확장자가 다양함)
![fig64](https://user-images.githubusercontent.com/40076487/75105211-e2c4a080-5654-11ea-9f3d-5d60d9af0559.png)
![fig65](https://user-images.githubusercontent.com/40076487/75105212-e35d3700-5654-11ea-80f1-907868015c4f.png)
![fig66](https://user-images.githubusercontent.com/40076487/75105213-e3f5cd80-5654-11ea-91ec-451a32696d26.png)
![fig67](https://user-images.githubusercontent.com/40076487/75105214-e3f5cd80-5654-11ea-828b-9c4d30ff9202.png)
![fig68](https://user-images.githubusercontent.com/40076487/75105215-e48e6400-5654-11ea-9ab5-a0c742611322.png)
![fig69](https://user-images.githubusercontent.com/40076487/75105216-e526fa80-5654-11ea-8772-7bbc8ba36cfe.png)

+ RStudio환경에서 R코드 vs. Jupyter환경에서 R코드 비교
  * RStudio환경에서 movielens데이터 분석
    - 예) 데이터 원본: https://grouplens.org/datasets/movielens/1m/
    - 예) R 코드 원본: http://popeye.snu.ac.kr/~hyoh/courses/R/movielens.R
    ![fig70](https://user-images.githubusercontent.com/40076487/75105217-e526fa80-5654-11ea-9fb8-961e5fffba6f.png)
    - Jupyter환경에서 movielens데이터 분석
    - 예) 데이터 원본: https://grouplens.org/datasets/movielens/1m/ 
    - 예) Jupyter 소스 원본: http://popeye.snu.ac.kr/~hyoh/courses/R/movielens.html
    ![fig71](https://user-images.githubusercontent.com/40076487/75105218-e5bf9100-5654-11ea-80a8-418ad048441d.png)
    ![fig72](https://user-images.githubusercontent.com/40076487/75105219-e6582780-5654-11ea-980d-ff7b2117127f.png)
+ Anaconda 환경에서 R수행하기
  * 아나콘다 설치
    - 아래 그림과 같이 Jupyter, R 기타 등등이 보임을 알 수 있음.
![fig73](https://user-images.githubusercontent.com/40076487/75105220-e6582780-5654-11ea-84fd-2fa034660223.png)
 + 윈도우 메뉴에도 Anaconda Prompt 메뉴가 보임
 ![fig74](https://user-images.githubusercontent.com/40076487/75105221-e6f0be00-5654-11ea-8f4b-e36d40f21436.png)
 + 다음과 같이 윈도우 콘솔에서 conda essential설치
 ![fig75](https://user-images.githubusercontent.com/40076487/75105222-e6f0be00-5654-11ea-93c1-c227b0b199a7.png)
 ![fig76](https://user-images.githubusercontent.com/40076487/75105223-e7895480-5654-11ea-9198-07f6bc473a6c.png)
 ![fig77](https://user-images.githubusercontent.com/40076487/75105224-e7895480-5654-11ea-9e64-86097d44104a.png)
 ![fig78](https://user-images.githubusercontent.com/40076487/75105225-e821eb00-5654-11ea-9a15-7ed05df31c51.png)
 ![fig79](https://user-images.githubusercontent.com/40076487/75105226-e8ba8180-5654-11ea-9aad-0a2e815975c6.png)
 ![fig80](https://user-images.githubusercontent.com/40076487/75105227-e8ba8180-5654-11ea-9644-985e02ea7e1a.png)

 
+ R기반 데이터 분석을 위해 데이터 생성 방법은 몇 가지가 있을까?
  * 1) 데이터 사이즈가 작은 경우
    - A.	소스에 처음부터 데이터를 생성해서 초기화 하는 방법
    - B.	키보드에서 데이터를 실시간으로 입력해서 생성하는 방법
  * 2)	데이터 사이즈가 어느 정도 이상으로 큰 경우
    - A.	엑셀파일이나 메모장 파일 등에 (빅) 데이터를 저장해서 RStudio에서 불러온 뒤 활용하는 방법
    - B.	인터넷 사이트에 접속 후, 온라인 데이터를 크롤링 한 뒤 엑셀파일이나 메모장 파일에 저장 후 RStudio에서 불러와서 활용하는 방법

+ R을 효율적으로 사용하기 위한 환경 (RStudio)에서 사용하면 좋을 키보드 예약어들은?
  * RStudio에서 새로운 소스 창을 띄우는 방법은?
    - 키보드: Ctrl+Shift+N
  * RStudio에서 질문을 하고 결과를 보여줘! 라는 컴파일(Compile)을 하는 방법은?
    - 키보드: Ctrl+Shift+S 혹은 Ctrl+Shift+Enter
  * RStudio의 소스상에서 특정 라인을 주석처리하는 방법은?
    - 키보드: Ctrl+Shift+C
![fig81](https://user-images.githubusercontent.com/40076487/75105228-e9531800-5654-11ea-8ffc-760fd7a80ade.png)
![fig82](https://user-images.githubusercontent.com/40076487/75105229-e9531800-5654-11ea-88c0-2a6c1521e344.png)
![fig83](https://user-images.githubusercontent.com/40076487/75105230-e9ebae80-5654-11ea-970a-2135b69abbe3.png)

+ 프로그래밍에서 주석 처리란?
  * 컴퓨터는 볼 수 없고 인간만 볼 수 있는 것
    - 예: 소스 설명, 소스 작성자 등등
    - 결과, 컴퓨터 문법에 맞지 않아도 되고 인간 언어들로 편하게 작성<br>
+ R의 특징 (주의사항 및 R 스터디 추천 사이트)
  * 알파벳 대/소문자 구분
    - 예) apple, Apple, aPPle, appLe, applE등은 서로 다른 변수
  * 데이터를 담는 컴퓨터 그릇(변수)의 이름
    - 알파벳으로 시작
      + 예) 2apple(x), _apple(x)등과 같이 숫자 혹은 특정 특수 기호로 시작하는 변수 이름은 불가능
    - 에서 이미 사용되고 있는 예약어들은 사용 불가능
      + 예) print, for, while, if 등과 같은 예약어들은 변수 이름으로 사용 불가능<br>
+ 컴퓨터 입장에서 (즉, RStudio 입장에서 혹은 R언어 입장에서)
  * “로 시작하는 단어 발견 시: 문자열
  *	“로 시작하지 않는 단어 발견 시: 변수
  *	“로 시작하지 않는 단어 발견하고 ( )가 있으면: 함수<br>

[참고] 변수란? 앞서 언급했듯이, 변수란 실제 데이터를 저장할 수 있는 컴퓨터 메모리 공간으로 변수명(변수이름)은 프로그래머가 변수명 만들기 규칙을 활용해서 자유롭게 작성하는 명령어입니다. [그림. 31번 참고]
![fig84](https://user-images.githubusercontent.com/40076487/75105231-e9ebae80-5654-11ea-9d65-5c5cdadd282c.png)
![fig85](https://user-images.githubusercontent.com/40076487/75105232-ea844500-5654-11ea-8583-c56c79899b51.png)
<center> 
    
   그림. 9.  변수의 정확한 정의
    
 <div style="text-align: left">
   
   * 다양한 자료 구조 존재
![fig86](https://user-images.githubusercontent.com/40076487/75105233-eb1cdb80-5654-11ea-891a-a7ebc1cf180b.png)
![fig87](https://user-images.githubusercontent.com/40076487/75105234-eb1cdb80-5654-11ea-9059-64c49807fe7c.png)
![fig88](https://user-images.githubusercontent.com/40076487/75105235-ebb57200-5654-11ea-9e54-a287e0ca13ae.png)

   * R스터디 추천 사이트
      - https://www.rdocumentation.org
+ 패키지 정의 및 RStudio에서 패키지 확인
  * 패키지란?
    - 특정 기능을 위해 개발된 패키지로 데이터, 변수, 함수 등을 포함.

![fig89](https://user-images.githubusercontent.com/40076487/75105236-ebb57200-5654-11ea-817a-aa4bff40ccc0.png)
+ RStudio오른쪽 하단화면에서 패키지의 종류 및 특성 확인
![fig90](https://user-images.githubusercontent.com/40076487/75105237-ec4e0880-5654-11ea-913a-64334a07a7b8.png)

+ 컴퓨팅 사고란?
  * 문제를 효율적으로 해결할 수 있는 사고의 틀
    - 분해
    - 패턴인식
    - 추상화
    - 알고리즘 
  * 컴퓨팅 사고의 필요성
    - 급변하는 시대에서 다양한 문제 및 현상 등을 효율적으로 해결하기 위해서는 (빅) 데이터 기반 컴퓨터를 활용하여 문제를 효율적으로 푸는 경향이 있음
    - 결과 사람이 컴퓨터(기계)를 이용해서 문제를 효율적으로 풀기 위해서는 컴퓨터가 어떻게 사고해서 문제를 풀어나가는지 “컴퓨팅 사고”를 해야함.
    - 본 교재에서는 실생활에서 접할 수 있는 기초 예제 및 응용 예제들을 컴퓨팅 사고 및 R로 코딩하여 객관적이고 효율적인 답을 도출하는 방법론을 소개.<br>

+ 컴퓨팅 사고는 구체적으로 어떻게 할 수 있고, 모든 문제는 컴퓨팅 사고로 풀리는가?
  * 컴퓨팅 사고는 IBM의 부사장이자 대학 교수인 자셋 윙이 2009년에 언급한 개념으로 앞서 언급했지만 분해, 패턴인식, 추상화 및 알고리즘으로 구성됨.
  * 컴퓨팅 사고는 기계 (예: 컴퓨터 등)가 문제를 효율적으로 해결할 때 자연스럽게 수행과는 과정으로 사람도 역시 컴퓨팅 사고를 하면 대부분의 계산 위주의 문제가 효율적으로/최적으로 풀림.
    - 즉, 모든 문제가 컴퓨팅 사고로 풀리지 않지만, 기계적으로 풀면 효율적인 대부분의 문제들은 컴퓨팅 사고적으로 풀면 큰 도움이 됨.<br>

+ 컴퓨팅 사고가 가능한 문제 유형 및 컴퓨팅 사고 정의를 고찰하면 어떤 요소가 있는가?
  * 컴퓨팅 사고는 소프트웨어학과에서 배우는 다양한 교과목(예: 자료구조 및 알고리즘등)에서 언급된 전문용어들의 의미 및 원리 등을 이해하면 많이 유사하다는 것을 알 수 있음. [그림. 10번 참고]
    - 예) 귀납적 알고리즘
    - 예) 분할 점령 알고리즘
    - 예) 탐욕적 알고리즘
      +	하지만, (비)전공자가 위와 같은 한자어 및 알고리즘 전문용어에 바로 노출되면 흥미를 잃고 어려움을 느낄 수 있기에, 그림. 10과 같이 우리말로 번역하여 “컴퓨팅사고(CT)의 각 단계와의 연관성”을 깊게 생각해볼 수 있음.
      +	그림. 10에서 앞서 설명한 컴퓨팅 사고 과정 (분해, 패턴인식, 추상화 및 알고리즘)이 그대로 (나누어 쪼개 풀기/분할점령, 다음 유도하기/귀납적, 알맹이 요약하기/추상화 및 다양한 알고리즘 기법) 기존 전문용어에 그대로 맵핑 됨을 알 수 있음.<br>

![fig91](https://user-images.githubusercontent.com/40076487/75105238-ec4e0880-5654-11ea-9fec-9c0ddc3a27ed.png)
그림. 10. 컴퓨팅 사고 과정과 자료구조 및 알고리즘과의 관계
+ 컴퓨팅 사고로 풀리는 문제 유형들 [그림. 11번 참고]
  * 계산 대상이 빅 데이터
    - 풀고자 하는 문제의 데이터 사이즈가 크고 패턴이 존재하면 유리함
   * 계산 유형의 문제들
     - 문제를 해결하는데 해결되는 과정에서 패턴이 존재하여 계산하면 유리한 문제들이면 효율적임<br>

![fig92](https://user-images.githubusercontent.com/40076487/75105239-ece69f00-5654-11ea-989e-830572b08bb5.png)그림. 11. 컴퓨팅 사고로 풀리는 문제 유형들
+ 컴퓨팅 사고, 주체는 누구인가? [그림. 12번 참고]
  * 컴퓨팅 사고로 문제를 누가 풀든, 컴퓨터 눈으로 문제를 바라보고 계산하면 효율 적임.<br>

![fig93](https://user-images.githubusercontent.com/40076487/75105240-ed7f3580-5654-11ea-8818-fa15d48a7869.png)
그림. 12. 컴퓨팅 사고의 주체, 계산 대상, 계산 자료 및 계산 과정
![fig94](https://user-images.githubusercontent.com/40076487/75105241-ed7f3580-5654-11ea-8d4f-77ac2cad83e4.png)
![fig95](https://user-images.githubusercontent.com/40076487/75105242-ee17cc00-5654-11ea-83f6-25f3261061bf.png)
![fig96](https://user-images.githubusercontent.com/40076487/75105243-ee17cc00-5654-11ea-8ed4-0976d57f06d0.png)
![fig97](https://user-images.githubusercontent.com/40076487/75105244-eeb06280-5654-11ea-9692-5377de5949cf.png)
![fig98](https://user-images.githubusercontent.com/40076487/75105245-ef48f900-5654-11ea-9090-1427ad0f92da.png)
![fig99](https://user-images.githubusercontent.com/40076487/75105246-ef48f900-5654-11ea-9cc0-e2876405c4a5.png)
![fig100](https://user-images.githubusercontent.com/40076487/75105247-efe18f80-5654-11ea-9590-d96dff4ed543.png)
![fig101](https://user-images.githubusercontent.com/40076487/75105249-f112bc80-5654-11ea-9b7f-ce4ec9d658fc.png))
+ 이산적 컴퓨팅 사고의 기초 예시는 무엇이 있을까가? [그림. 13번 참고]
  * 컴퓨팅 사고로 문제를 누가 풀든, 컴퓨터 눈으로 문제를 바라보고 계산하면 효율 적임.
  * 문제 별, 분해할 수 있는 기준을 정하고 최대한 기능별 작게 쪼개어 문제 풀기 시도
    - 숫자 맞추기 게임은 난이도를 하, 중, 상으로 점점 컴퓨팅 사고적으로 확장할 수 있기 때문에 (비)전공자 컴퓨팅 사고 기반 R교육 기초 및 응용확장까지 유용함.<br>

![fig102](https://user-images.githubusercontent.com/40076487/75105251-f1ab5300-5654-11ea-9651-2c66cb8cf245.png)
그림. 13.이산적 컴퓨팅 사고로 적합한 숫자 맞추기 게임 예시
+ 숫자 맞추기 게임 예제를 이산적 컴퓨팅 사고의 과정을 구체적으로 살펴보면? 
  * 앞서 언급한 컴퓨팅 사고 4단계를 숫자 맞추기 게임 예제에 이산적으로 (각 단계별로 잘 구분ㄷ하여) 적용해봄으로써, 컴퓨팅 사고과정을 구체적으로 학생들에게 노출 시킬 수 있음.<br>
![fig103](https://user-images.githubusercontent.com/40076487/75105253-f3751680-5654-11ea-9d95-fc076dd0acbb.png)
![fig104](https://user-images.githubusercontent.com/40076487/75105259-f5d77080-5654-11ea-9df1-ac759f46c8ce.png)
그림. 14. 숫자 맞추기 게임 예시에서 컴퓨팅사고(패턴인식 및 추상화 과정)예시
![fig105](https://user-images.githubusercontent.com/40076487/75105265-f7a13400-5654-11ea-84f3-5270538f93b2.png)
![fig106](https://user-images.githubusercontent.com/40076487/75105274-fa9c2480-5654-11ea-815a-becd82658c74.png)
![fig107](https://user-images.githubusercontent.com/40076487/75105278-fcfe7e80-5654-11ea-875d-2e2f67ca7f42.png)
![fig108](https://user-images.githubusercontent.com/40076487/75105283-fec84200-5654-11ea-99ce-6a794c6fe69b.png)
![fig109](https://user-images.githubusercontent.com/40076487/75105290-012a9c00-5655-11ea-91f7-c80966cf451f.png)
그림. 15. 숫자 맞추기 게임 예시에서 컴퓨팅사고(추상화)단계 예시
+ 숫자 맞추기 게임 예제를 이산적 컴퓨팅 사고의 마지막 과정인 알고리즘 단계에서 구체적으로 살펴보면? 
  * 알고리즘
    - 자연어
    - 순서도
    - 슈도 코드<br>

![fig110](https://user-images.githubusercontent.com/40076487/75105292-01c33280-5655-11ea-87cd-f1fafc2c5edb.png)
그림. 16. 숫자 맞추기 게임 예시에서 컴퓨팅 사고(알고리즘)단계에서 다양한 유형들

![fig111](https://user-images.githubusercontent.com/40076487/75105293-038cf600-5655-11ea-9b81-a9c02f81bb40.png)
그림. 17. 컴퓨팅 사고 표현에 활용될 수 있는 순서도 기호 (기본 및 응용)
![fig112](https://user-images.githubusercontent.com/40076487/75105297-0687e680-5655-11ea-83c2-51b14fbaf2a6.png)
![fig113](https://user-images.githubusercontent.com/40076487/75105300-0ab40400-5655-11ea-872c-a448af4bf0a2.png)그림. 18. 컴퓨팅 사고(알고리즘)단계에서 숫자 맞추기 게임 순서도 작성 및 R코드 예시
+ 숫자 맞추기 게임 예제를 기존의 유명한 (예: 이미 검증되고, 많이 활용되는) 최적의 알고리즘 원리와 비교해보면? 
  * 이진탐색 트리
![fig114](https://user-images.githubusercontent.com/40076487/75105301-0be53100-5655-11ea-986e-0a7319f2b268.png)
그림. 19. 이진탐색 알고리즘과 컴퓨팅 사고에서 알고리즘 단계 과정 비교 예시
[참고] 숫자 맞추기 게임을 컴퓨팅사고를 통해 자기 스스로 기초에서 확장까지 할 수는 없을까? 다음은, 교실 밖에서도 언제든지 수행할 수 있는 플립드 러닝을 활용하여 학생들이 자기주도학습을 할 수 있는 보고서 샘플 예시를 보여준다.
<center> 
    
   [CT기반 R응용] 자기주도학습 보고서-예시
    
 <div style="text-align: left">

다음은 숫자 맞추기 게임(기초 및 응용)이 수행되는 코드이다.
코드 파일명의 예) 작성날짜_game_학생 본인학번.R


<center> 
    
   20190220_game_113445_try_break2.R
    
 <div style="text-align: left">
 
![fig_pratice1](https://user-images.githubusercontent.com/40076487/75105146-cde80d00-5654-11ea-9c8b-0d4daea486c0.png)

즉, 숫자 맞추기 게임 (기초) 및 (응용- 사용자가 원하는 횟수만큼 게임 진행, 현재 몇번 째 게임 중인지 출력, 앞으로 게임이 몇번 남았는지 출력-단, 마지막 게임에서는 남은 횟수 미출력, 게임에서 틀린경우 힌트 출력 등)의 초안은 수업시간과 flipped learning 을 통해서 모두 다 같이 수행했다. 위까지 완성된 숫자 맞추기 게임 소스(20190220_game_113445_try_break2.R)에 아래를 반영하여 이메일로 제출하세요<br> 
[마감일] 10월 31일 밤 12시,<br>
[이메일로 제출, 첨부파일] R소스 원본, 워드보고서 혹은 Jupyter기반 html파일<br>

1. “숫자 맞추기 게임 (기초) 및 (응용)”에서 개인이 스스로 추가적으로 창의적으로 생각한 아이디어/시나리오를 아래 페이지에 한글로 작성(분량은 자유)---구글 검색 및 안드로이드 앱 마켓에서 등록된 다양한 숫자맞추기 형태의 게임 앱의 정보를 참고하고 다운로드 받아서 수행해보고 느끼고 작성 등등
(부분점수)
추가적인 아이디어/시나리오 작성시 5점 (숫자 2개 맞추기라던지 등등)
앱 마켓에 등록된 게임 등 여러가지 게임 사례를 분석하여 느낀점을 토대로 새로운 아이디어 제안시 5점 
+ -> 그냥 아이디어 제안시 5점, 게임을 분석하여 새로운 아이디어 창출시 10점

2. 위 1번에서 스스로 추가적으로 생각해서 작성한 시나리오를 20190220_game_113445_try_break2.R 에서 완성하기 위해서 R 예약어, R 함수, R 변수, R 패키지등 어떤 것들을 조합해서 명령어를 만들어야 하는지 생각해보고 생각의 흔적을 자유롭게 아래에 작성(분량은 자유)---수업시간에 쓰는 필기노트에 작성했던 것처럼 자유로운 형태로 작성. 구글링해서 R 예약어, R 함수, R 변수, R 패키지등 검색 후 공부하면서

(부분점수)
단순히 필요한 R 예약어, R,함수, R변수, R 패키지 등을 작성하였을시 5점<br>
각 예약어, 함수, 패키지등이 어떻게 연결되고 어떤 역할을 하는지 자세히 적으면 5점<br>
+ -> 단순히 필요한 것들만 적으면 5점, 필요한 것들을 분석하여 자세히 적으면 10점
3.	위 1번과 2번을 20190220_game_113445_try_break2.R 에서 직접 코딩하고 실행해서 나온 흔적들 (예: 기본 코드에 본인이 추가한 명령어 마다 # 한글로 주석을 달아서 구분시켜놓고, 실행해서 나온 결과화면들-실패난 경우도 에러문구가 보이도록 화면 캡춰후 아래에 붙여넣고, 스스로 에러를 직접 읽고 에러를 발생시키는 코드 라인 스스로 찾아서 스스로 고쳐보고 실행후, 에러 없어졌다면 흔적을 캡춰 후 아래에 역시 붙여넣기 등등)을 최대한 다양하고 많이(즉, 다각도에서 테스트 수행해서) 성실하게 진행한 과정을 친절하게 붙여놓고, 각 사진마다 한글로 설명 달아놓기.

(부분점수)
1번 문제의 아이디어를 토대로 코드 작성후 각 라인별 주석 작성시 5점<br>
1번 문제의 아이디어를 토대로 코드를 작성하여 실행하였으나 에러가 난 경우 5점<br>
1번 문제의 아이디어 대로 동작하면 15점<br>
+ -> 주석 작성+코드 에러시 10점, 주석 작성+코드 동작시 20점

4.	아래 예시와 같이 본인의 소스를 어떤 경우로 분리해서 테스트했는지 정리해서 아래에 붙여넣기

![fig_pratice2](https://user-images.githubusercontent.com/40076487/75105147-ce80a380-5654-11ea-82ef-45c9e4022696.png)

+ 숫자 맞추기 게임 예제를 난이도 “중”으로 올려서, 문자 맞추기 게임으로 시도해보려면? 
  1)	컴퓨팅 사고과정을 문자 맞추기 게임에 도입하며 스스로 시도
  2)	아래 워크 시트에 위 예제를 바탕으로 스스로 작성해보기
  3)	완성 후, 여전히 이진탐색 트리 알고리즘이 활용되는 것인지 스스로 비교 및 생각
![fig115](https://user-images.githubusercontent.com/40076487/75105304-0c7dc780-5655-11ea-892f-f1267b054e8f.png)
그림. 20. 문자 맞추기 게임 (컴퓨팅 사고 과정 워크 시트 예시)<br>

+	문자 맞추기 게임 예제를 난이도 “상”으로 올려서, 단어 맞추기 게임으로 시도해보려면? 
  1)	컴퓨팅 사고과정을 단어 맞추기 게임에 도입하며 스스로 시도
  2)	아래 워크 시트에 위 예제를 바탕으로 스스로 작성해보기
  3)	완성 후, 여전히 이진탐색 트리 알고리즘이 활용되는 것인지 스스로 비교 및 생각
  4)	기존의 Google, Naver등에서 사용자가 오타 검색어 입력시, 자동으로 올바른 검색어를 추천해주는 기능과의 유사점 및 차이점을 팀원들과 논의 후 팀별 과제 시도
  5)	숫자 -> 문자 -> 단어 -> 문장 (한글, 영어 등등) 으로 문제 난이도를 높여서 개인별/팀별 컴퓨팅 사고 기반 문제 해결 능력 과정을 플립드 러닝으로 해결 시도
![fig116](https://user-images.githubusercontent.com/40076487/75105305-0d165e00-5655-11ea-9aa8-046869219c6c.png)
[참고] 컴퓨팅 사고와 리버럴 아츠 교육? 은 어떤 관련이 있을까요? 왜 전세계적으로 초,중,고 및 대학교에서 소프트웨어 기초 교육을 수행하게 됐을까요? 이 부분은 저자 책의 R기초 파트에서 R응용 파트로 넘어가기전에 매우 중요한 동기 부여를 제공해 주기 때문에 충분한 설명이 필요합니다. [9]

+	광범위한 지식정보 분야에서 온라인 정보망 및 기술 등의 눈부신 발전으로 오프라인 활동을 뛰어넘어 새로운 문제들이 제시됨에 따라 인문, 자연, 사회, 경영, 의대, 간호 등 전공에 무관하게 컴퓨팅 사고를 바탕으로 문제를 해결하는 융복합 능력이 중요하게 되었습니다. 특히, 사회적인 관점에서는 경제, 과학기술 분야뿐 아니라 교육, 행정, 법과 안보, 사회와 문화 등 우리 사회 대부분의 분야에의 우리 사회 구성원 모두- 정부와 기업, 노동자와 소비자, 그리고 우리 사회 모든 구성원-에게 컴퓨팅 사고 발상의 혁명적 전환이 필요합니다. 컴퓨팅 사고 (Computational Thinking: CT)는 어떤 문제든 분해, 패턴인식, 추상화 및 알고리즘이라는 4단계를 거쳐서 효율적으로 사고하는 방법론입니다. 컴퓨팅 사고를 활용해서 문제를 풀면 통찰력 (Insight) 을 키울 수 있으며 기존의 아는 지식으로부터 새로운 문제를 해결하는 연결 능력 (Connectivity Capability) 을 키울 수 있습니다. 즉, 시시각각 변화하는 세상에서 새롭게 주어지는 어떤 문제든 불필요한 과정은 제거하고 문제의 핵심과 본질에 집중, 통찰하여 효율적으로 문제를 풀 수 있습니다. 이는 4차 혁명, 3D 프린팅과 퀀텀 컴퓨팅, 나노 및 바이오 기술, 빅 데이터, 클라우딩 및 인공지능 시대에 살고 있는 우리에게 “컴퓨팅 사고” 교육의 중요성을 제시합니다.
+	인간은 동시대에서 새롭게 풀어야하는 혹은 흥미로운 여러 과제들을 항상 수반합니다. 최근 급변하는 시대에서는 이미 알고 있는 지식, 사람으로써 자연스럽게 가지고 있는 본능을 뛰어 넘어 1인 1로봇 시대, 현실 확장, 가상 현실 등의 미래 창출 기술 등이 현실화되고 있습니다. 즉, 인간은 새로운 문제를 어떻게든 풀고 실현시키고자 하는 욕구가 있는 것입니다. 이를 위한 근본적인 해결책 중 하나는 “컴퓨팅 사고”입니다. 사실, 컴퓨팅 사고는 공기와 같이 주변 어디에든 존재해 왔으며 난이도에 상관없이 어떤 문제든 자연스럽게 논리적으로 문제가 풀려나가는 방향입니다. 주어진 문제가 생활 속에서 쉽게 발생하는 문제였다면 고대시대부터 사람들이 자연스럽게 해결해왔던 순서가 컴퓨팅 사고이며 주어진 문제가 특정 학문 및 전공분야에서 난이도 있는 문제 혹은 인간의 삶 속에서 발생한 복잡한 문제 (Complex problem)라면 컴퓨팅 사고 4단계 과정이 범위와 깊이 측면 (Breadth and Depth) 에서 더욱 정교화되고 세분화되어 정립되기 때문에 시간이 좀 더 걸리는 것입니다.
+	앞서 언급했지만 우리는 지금 전 세계적으로 사회, 산업, 문화적 르네상스를 불러온 과학기술의 대전환 기에 살 고 있습니다. 제 4차 산업혁명의 속도, 범위 및 깊이는 급변하고 있으며 새로운 기술의 가능성을 최대한 활용할 수 있는 창의적인 아이디어는 누구든지 생각하고 소프트웨어 기술을 활용하여 가시화시키면 상품을 만들 수 있도록 열려있습니다. 기업은 이를 최대한 활용하여 가치를 창출하고자 하고 국가는 국제사회속에서 새로 시작될 위대한 여정을 준비하고자 합니다. 또한, 개인은 전공에 무관하게 컴퓨터와 기계를 활용하여 최적으로 문제를 풀고 다각도에서 이를 활용하고자 합니다. 결과, 기하급수적인 속도로 다가오는 제 4차 산업혁명 시대를 대비해 교육 분야의 전면적 개혁의 필요성은 누구나 짐작할 것이고 특히 대내적으로 개편된 컴퓨팅 사고 기반 교양 교육은 매우 중요하다고 볼 수 있습니다. 새로운 일자리 창출을 꿈꿀 수 있는 창의력을 갖춘 인재와 새로운 일자리에 최적화된 능력을 지닌 인재는 컴퓨팅 사고력을 갖추도록 도움을 주는 교육 제도, 방법 및 교육 내용으로 키워질 수 있기 때문입니다.
+	사실, 컴퓨팅 사고의 궁극적인 목표는 교양 교육의 일환인 리버럴아츠 교육(Liberal Arts Education)의 핵심과 유사합니다. 그림 21과 같이 리버럴아츠 교육의 목표는 ‘창의 교육’이나 ‘융복합 교육’을 통해 창의력 기반의 문제 해결능력을 키워주는 것입니다. 역설적이게도 ‘고전적인’ 리버럴아츠 교육이 21세기 디지털 정보사회에서 더욱 필요한 기초 교양 교육이 된 것입니다 [1]. 최근, 세계 경제포럼에서는 미래 2020년에 요구되는 대표적인 10가지 기술 중 전공과 무관하게 어떤 복잡한 문제가 주어지더라도 해결하고 비판(비평)적으로 생각할 수 있는 힘을 1순위 및 2순위로 뽑았습니다. 그림. 22. 는 2020년에 요구되는 대표적인 10가지 기술과 지난 2015년에 필요했던 기술들을 비교해서 보여줍니다. 이 또한, 전 세계적으로 컴퓨팅 사고 교육이 절실하게 필요하다는 것을 보여주는 지표입니다.

![fig117](https://user-images.githubusercontent.com/40076487/75105306-0d165e00-5655-11ea-8646-755d15a6c6d9.png)
그림. 21. 리버럴아츠 교육(Liberal Arts Education)과 컴퓨팅 사고 교육
![fig118](https://user-images.githubusercontent.com/40076487/75105307-0daef480-5655-11ea-8f1f-a7fabadccb1a.png)
그림. 22. 2020년에 요구되는 대표적인 10가지 기술 [4][5][6]
[참고] 컴퓨팅 사고를 하려면 프로그래밍을 무조건 배워야 할까요?
+	컴퓨팅 사고란 주어진 문제를 최적의 방향으로 풀 수 있는 문제 해결 능력입니다. 여기서 “최적의 방향”이란 주어진 문제를 해결할 수 있는 다양한 방법들 중에서 문제의 본질에 집중하여 이를 해결하고 통찰력을 키우는 것을 의미합니다. 컴퓨팅 사고를 한다고 컴퓨터가 이해 및 계산 할 수 있는 프로그래밍 기술과 컴퓨터를 꼭 활용 해서만 문제를 해결하는 것을 의미하지 않습니다. 다만, 어떤 문제든 컴퓨팅 사고 절차를 따라서 해결책을 만들면 마지막 단계에서 정립된 알고리즘이 나오기 때문에 컴퓨터를 이용해서 최종 결과 가시화에 효율적이라는 것을 의미합니다. 특히, 컴퓨터가 이해하는 프로그래밍 언어는 처음부터 컴퓨팅 사고의 4단계를 최대한 잘 표현, 활용 및 확장 될 수 있도록 처음부터 설계되어 디자인된 언어, 툴, 이기 때문에 컴퓨팅 사고를 거쳐서 나온 알고리즘은 거의 그대로 해당 프로그래밍 언어로 변환되기 쉽다는 것을 의미합니다. 일반적으로 컴퓨팅 사고를 통해서 나온 알고리즘은 자연어, 순서도 (flow chart), 다이어그램 (diagram), 슈도 코드 (pseudo code)등으로만 표현되기 때문에 컴퓨터에서 바로 실행되지는 않는 단계라고 볼 수 있습니다. 여기서 자연어는 향후 프로그래밍 코드에서 각 명령어 (instruction)에 추가 설명인 주석 (comment)로 활용될 수 있기 때문에 공동 작업을 하는 프로그래머들 사이에서 가독성 (readability) 을 높여줄 수 있습니다. 또한, 순서도는 다이어그램의 종류 중 하나로 그림. 23와 같이 어떤 문제든 공통적으로 고려되야하는 입출력, 처리, 판단 등을 도형으로 표현하여 이해도 (understanding capability)을 높이기 때문에 문제의 동적 요소들을 표현하기에 적합합니다. 특히, 순서도는 어떤 일을 처리할 때 여러 종류의 상자와 이를 이어주는 화살표를 이용해 ‘명령의 순서’를 보여주는 알고리즘(algorithm) 혹은 프로세스(process) 디자인에 대표적으로 활용되는 방법입니다. 여기서 알고리즘이란 컴퓨팅 사고를 거쳐서 나온 주어진 문제를 해결하기위한 여러동작들의 순차적인 모임을 의미하며, 프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말합니다. 즉, 순서도는 컴퓨팅 사고 결과 나온 알고리즘 표현에도 사용될 수 있으며 향후 프로그래밍 언어로 변환되어 확장된 뒤 실제로 실행되고 있는 과정 (프로세스) 을 표현할 때도 활용될 수 있습니다.
![fig119](https://user-images.githubusercontent.com/40076487/75105308-0e478b00-5655-11ea-93ab-87c1bfd97d56.png)
그림. 23. 컴퓨팅 사고 표현에 활용될 수 있는 순서도 기호들 (기본 및 응용)

슈도(Pseudo: 가짜의) 코드 혹은 의사(疑似: 비교할 의, 비슷할 사) 코드는 그림. 24와 같이 컴퓨팅 사고과정을 표현할 때 각 모듈이 작동하는 논리 및 사고를 좀더 명확히 정립하게 만들어주어 향후 프로그램을 설계하는데 도움이 됩니다. 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 우리가 일반적으로 사용하는 언어 (예: 한국어 혹은 영어 등)로 간략히 서술해 놓은 것이기 때문에 역시 컴퓨터에서 실행할 수 없으며, 특정 언어로 프로그램을 작성하기 전에 알고리즘의 모델을 대략적으로 모델링하는 데에 쓰입니다. 컴퓨팅 사고 과정을 슈도 코드로 작성하는 것은 그림. 25와 같이 향후 컴퓨터 프로그래밍을 통해 결과를 가시화함에 있어 효율성을 높여줍니다. 예를 들어서, 컴퓨팅 사고 4단계를 거치면 주어진 문제가 기능 및 객체 별 분해가 되고 각 분해된 조각들 중에 기능적으로 반복되거나 상태 및 동작의 패턴 등을 찾을 수 있습니다. 또한, 추상화과정을 통해서 문제의 세부 정보는 삭제되며 문제에서 꼭 필요한 독립변수 (Independent variable)과 종속 변수 (Dependent variable)가 정의되고 해당 변수들 간의 관계를 알 수 있는 일반화된 식 (Equation) 혹은 구조 (structure)가 정의됩니다. 이때 마지막 과정에서 실제로 해당 해결과정이 동작함에 있어서 순차적으로 나열되는 알고리즘을 통합적인 관점에서 디자인하게 되는데 이 과정을 슈도 코드로 작성하게 되면 그림. 15와 같이 향후 실제 동작하는 프로그램으로 변환 시 많은 오버헤드를 줄일 수 있기 때문에 상품화까지 나오는데 유용한 방식이라고 볼 수 있습니다.  
![fig120](https://user-images.githubusercontent.com/40076487/75105309-0ee02180-5655-11ea-8ab6-1135a8b7919e.png)
![fig121](https://user-images.githubusercontent.com/40076487/75105310-0f78b800-5655-11ea-9cce-72d48610843c.png)

<center> 
    
   그림. 24. 컴퓨팅 사고 표현에 활용될 수 있는 슈도 코드 예시 [7]
   ![fig122](https://user-images.githubusercontent.com/40076487/75105311-10114e80-5655-11ea-9fa0-dc058620cb1b.png)
그림. 25. 컴퓨팅 사고 기반 문제해결과정 (슈도 코드 사용 전&후 오버헤드 비교)
 
 <div style="text-align: left">

+	컴퓨터 및 프로그래밍은 주어진 문제에 대해서 최적으로 해결할 수 있는 도구 중 하나입니다. 결과 컴퓨터를 사용하면 인간보다 빨리 더욱 효율적으로 문제를 풀 수 있는 경우가 많습니다. 일반적으로, 컴퓨터 및 프로그래밍은 주어진 문제가 분해(decomposition), 패턴 찾기(pattern recognition), 추상화(abstraction) 및 절차적 알고리즘(algorithm)이라는 컴퓨팅 사고 적(computational thinking)으로 기술 됐을 때 이를 ‘거의 그대로’ 활용할 수 있습니다. 결과 때로는 컴퓨팅사고를 교육하는데 MIT에서 만든 스크래치 [8], 네이버 엔트리, 파이썬 및 R등의 초보자에 적합한 프로그래밍을 주로 활용하는 이유이기도 합니다. 하지만 앞서 언급했듯이 컴퓨터가 이해할 수 있는 단계가 완벽하게 되려면 프로그래밍, 코딩이라는 개념이 들어가야하기 때문에 추가적인 오버헤드가 발생합니다. 즉, 컴퓨팅 사고는 프로그래밍 및 코딩이라는 개념과 동일하지 않으며 일반적으로 프로그래밍 전 단계에서 수행되는 사고의 과정입니다. 컴퓨팅 사고는 주어진 문제에 따라서 4단계의 사고 과정이 이산적인 개념 (discrete concept)으로 발생되기도 하고 연속적인 개념 (continuous concept)으로 발생할 수도 있습니다. 분해, 패턴, 추상화 및 알고리즘이라는 4단계가 정확하게 분리되면서 컴퓨팅 사고인 문제 해결 사고과정이 발생하면 이산적인 개념 (discrete concept)기반 컴퓨팅 사고라고 할 수 있습니다. 하지만 특정 복잡한 문제들은 컴퓨팅 사고의 4절차의 경계 점이 분명하지 않고 연속적인 개념 (continuous concept)으로 발생할 수도 있습니다. 본 저서에서는 컴퓨팅 사고를 처음 접하는 다양한 학과의 (비)전공자 학생들에게, 이산적인 개념 기반 컴퓨팅 사고 4절차 (Discrete Concept based Computational Thinking: DC based CT)를 활용해서 실제 소프트웨어 기초교육을 시도한 예제들을 소개합니다.

+ [참고] (비)전공자들에게 컴퓨팅사고력 기반 문제해결능력 향상을 시켜주려면 교수/교사 분들은 어떻게 교육 시키고, 학생들은 어떻게 학습해야 할까요?
+	본 저서에서는 (비) 전공자 학생들이 통찰력을 발달시키고, 상황을 분석하고, 결론을 이끌어내는 것에 집중할 수 있는 ‘이산적인 컴퓨팅 사고 교육 방법론’을 소개합니다. 이를 위해, 본 저서에서는 컴퓨팅 사고 4단계가 분명하게 구분된 대표적인 기초 예제들을 개발했으며 해당 문제들을 학생 스스로 언제 어디서나 확장할 수 있도록 플립드 러닝 교육방법을 소개합니다. 플립드 러닝을 기회 적으로 (opportunistically) 활용한 이유는 강의실에서만 이뤄지는 오프라인 수업의 한계점을 뛰어 넘어 학생들이 언제 어디서나 새로운 아이디어를 만들고 기존에 알고 있던 지식에서 패턴을 찾아서 연결하는 과정과 기회를 제공하기 위해서 입니다. 일반적으로 컴퓨팅 사고를 활용한 문제 해결 과정은 입시제도의 단순 계산 및 점수 서열화를 목적으로 하는 단순 반복 유형의 단답형 문제 유형들과 다르기 때문에 개인별 그리고 수준별 소요되는 시간과 문제 해결 과정이 다양할 수 있습니다. 따라서 강의실에서 오프라인으로 진행되는 정규 수업만으로는 부족할 수 있다. 결과, 제안하는 컴퓨팅 사고 교육 방법론에서는 그림. 26과 같이 플립드 러닝 [3]을 활용하여 강의실 밖에서 언제 어디서나 학생들이 원하는 장소와 시간에 컴퓨팅 사고를 위한 충분한 시간을 가질 수 있도록 촉매제를 제공하는 것을 제안합니다. 학생들은 팀별 혹은 개인별 강의실 안과 밖에서 교수자가 제공하는 플립드 러닝 (flipped learning) 자료 활용할 수 있으며 이를 자유롭게 학생 아이디어에 연결하고 컴퓨팅 사고를 통해 주어진 문제 해결의 숨겨진 패턴과 원리(통찰)를 찾을 수 있습니다.

![fig123](https://user-images.githubusercontent.com/40076487/75105312-10a9e500-5655-11ea-8287-a5b804d79f6e.png)
그림. 26. 예시) 아주대학교 블랙보드(온라인영상강의 Collabo) [3]기반 플립드 러닝과 컴퓨팅사고를 융합하는 교육 방법론

본 저서에서는 많은 예제들 중에서 이산적 컴퓨팅 사고 교육을 위한 구체적인 예제로 누구나 한번쯤은 경험했을 만한 “숫자 맞추기 게임”을 소개합니다. “숫자 맞추기 게임”은 임의의 숫자를 선택하는 객체1과 이를 맞추는 객체2가 필요합니다. 객체1은 컴퓨터가 될 수도 있고 사람(사용자1)일 수도 있다. 일반적으로 객체2는 사용자2로 칭합니다. 게임의 구체적인 절차는 다음과 같습니다. 사용자1은 1개의 숫자를 혼자만 머릿속으로 생각하고 사용자2는 이를 맞춰 나갑니다. 게임은 1번의 기회를 줄 수 있지만 틀린 경우 힌트를 주고 사용자2가 원하는 만큼 게임을 진행 할 수 있습니다. 해당 게임을 컴퓨팅 사고 관점에서 풀기 위해서는 크게 분해, 패턴, 추상화 및 알고리즘 단계를 학생들이 직접 생각하면서 서술해 봐야합니다. 예를 들어서, 컴퓨팅사고를 도입해서 숫자 맞추기 게임을 해결하는 과정을 나열하면 그림. 27과 같습니다.

![fig124](https://user-images.githubusercontent.com/40076487/75105313-11427b80-5655-11ea-8904-af863069b17a.png)
<center> 
    
   그림. 27. 컴퓨팅 사고 기반 숫자 맞추기 게임
 <div style="text-align: left">
   그림. 28은 앞서 언급했듯이, 숫자 맞추기 게임을 해결하기 위한 컴퓨팅 사고 과정 (분해, 패턴, 추상화, 알고리즘)을 좀 더 구체적으로 ‘한번에’ 보여줍니다. 학생들은 분해과정에서 객체 및 기능별 문제를 분해할 수 있으며 역할극을 상상해보면서 게임 패턴이 존재한다는 것을 파악할 수 있습니다. 또한, 문제 본질의 핵심만 남기는 추상화과정을 기록해볼 수 있으며 실제로 문제가 풀려나가는 과정을 나열하는 알고리즘을 디자인해볼 수 있습니다. 이때 실제 동작되는 경우의 수가 그림. 28(d)와 같이 매우 다양할 수 있기 때문에 컴퓨팅 사고과정을 스스로 충분히 생각해보고 종이에 기록하면서 모든 경우를 생각해보는 충분한 시간이 필요합니다. 이는 정규수업시간이외 플립드 러닝으로 개인 맞춤형 컴퓨팅 사고로 연결시킬 수 있습니다.

![fig125](https://user-images.githubusercontent.com/40076487/75105315-11db1200-5655-11ea-8a54-06cde5bb931f.png)
<center> 
    
   그림. 28. 컴퓨팅 사고 기반 숫자 게임, (a) 분해[2]
 <div style="text-align: left">
 
![fig126](https://user-images.githubusercontent.com/40076487/75105316-13a4d580-5655-11ea-8afc-77b91d400b6b.png)
<center> 
    
   그림. 28. 컴퓨팅 사고 기반 숫자 게임, (b) 패턴
 <div style="text-align: left">  

![fig127](https://user-images.githubusercontent.com/40076487/75105317-156e9900-5655-11ea-8b84-afeea5249521.png)
<center> 
    
   그림. 18. 컴퓨팅 사고 기반 숫자 게임, (c) 추상화
 <div style="text-align: left">  
    
    
![fig128](https://user-images.githubusercontent.com/40076487/75105318-16072f80-5655-11ea-8014-77e53a7e7a62.png)
<center> 
    
   그림. 28. 컴퓨팅 사고 기반 숫자 게임, (d) 알고리즘(자연어 기반)
 <div style="text-align: left">

![fig129](https://user-images.githubusercontent.com/40076487/75105319-16072f80-5655-11ea-8770-cd9b0dd8544d.png)

<center> 
    
   그림. 28. 컴퓨팅 사고 기반 숫자 게임, (d) 알고리즘(순서도 기반)과 동작되는 경우의 수
 <div style="text-align: left">
    
그림. 28. 컴퓨팅 사고 기반 숫자 맞추기 게임 (세분화 과정) (a) 분해[2], (b) 패턴, (c) 추상화, (d) 알고리즘(자연어 기반, 순서도 기반)

[참고] (비)전공자 이산적 컴퓨팅 사고력 향상을 위한 R응용 강의 계획안은 어떻게 작성할 수 있을까요? 즉, 기존 수업 계획안과 달리, 컴퓨팅사고력 기반 문제해결능력 향상을 시켜주려면 교수/교사 분들은 어떤 계획안을 바탕으로, 어떻게 교육 시키고, 학생들은 그룹 토론 및 CT 어떻게 학습해야 할까요?

<center> 
    
   CT 강의 계획안 예시<br>
[(비)전공자 이산적 컴퓨팅 사고력 향상을 위한 R응용]

 <div style="text-align: left">
    
## 강의 세부 계획안 (16주 / 28차시)

+	수업은 ‘개념이해(이론) -> 기본 문제(이론) -> 기본 문제(개인실습, 평가) -> 심화 문제 (팀 토론, 평가) -> 회고’의 과정으로 강의주제에 따라 1주 혹은 2주의 일정으로 구성함
+	기본 문제의 경우, 계산 문제와 일반 문제를 각각 포함하는 예시를 제공함
+	심화 문제는, 기본 문제에서 개인/팀 별 아이디어를 내서 확장 하거나, 교수가 주는 다양한 힌트를 반영해서 도전하도록 함.
+	MIT scratch의 10종류 블록, 순서도 및 슈도코드등을 활용해서 CT과정을 눈으로 쉽게 확인하고 “재활용”기능의 중요성을 직간접적으로 배울 수 있도록 함
+	궁극적으로 R기반 예제를 완성하고 시각화 함


<div style="text-align: left">
    
|<div style="text-align: left">주차 |<div style="text-align: left">차시 |<div style="text-align: left">강의주제 |<div style="text-align: left">수업내용(문제) |<div style="text-align: left">운영방안 및 평가요소 |
|:---------|:--------|:--------|:----------|:---------|
|1|1|<div style="text-align: left">컴퓨터 및 CT 개요|<div style="text-align: left"> 컴퓨터 및 CT 강의개요|<div style="text-align: left">이론|
|-|2|-|<div style="text-align: left">컴퓨터 및 CT 역사 및 다양한 정의<br>컴퓨터 및 CT 핵심 개념 (예: 계산대상, 계산자료, 계산과정)<br>CT 단계 (예: 알갱이로 요약, 자기 유도, 쪼개서 풀고 합치기, 눈앞 찾기 등등)<br>CT문제가 가능한 유형 소개 (예: 계산 유형 문제들)<br>CT 응용사례|<div style="text-align: left">이론|
|2|3|<div style="text-align: left">분해|<div style="text-align: left">‘분해’ 개념 <br> 간단한 분해 문제<br> Scale, Function, Role, Condition 등 분해의 단위로 생각해 볼만한 기준에 대한 이해<br> ① 성적증명서- 학생 점수만 뽑아서 정렬, 평균<br>(실습) 학생 점수 검색, 정렬, 평균 계산<br>② 최단거리- 두 도시간의 거리만 뽑아서 경로 계산<br> (실습) 지도에서 두 도시 검색, 거리 계산, 경로 계산|<div style="text-align: left">이론실습 (평가)|        
|-|4|-|<div style="text-align: left"> 복잡한 분해 문제<br>문제 요구사항 정의는 함께 진행 후, ‘분해’ 과정은 팀 토론으로 정리 유도<br>①	일상 생활 속의 기계 작성 원리 소개(예: 라면 자동 끓이기, 세탁기, 자동차의 원리 등등)<br>②	숫자 맞추기 게임 -> 단어 맞추기 게임<br>|<div style="text-align: left">	팀 토론 (평가)|
|3|5|<div style="text-align: left">패턴인식|<div style="text-align: left">‘패턴’ 개념<br>간단한 패턴 문제<br>일정한 경향, 반복적 규칙, 공통적 속성을 찾는 과정에 대한 이해<br>①	사전 검색<br>② 숫자 맞추기 게임 -> 단어 맞추기 게임<br> (실습) 순서가 존재하는 데이터는 비교를 통해서 불필요한 그룹은 제외하는 패턴이 존재함을 확인<br>|<div style="text-align: left">이론 실습 (평가)|
|-|	6|-|<div style="text-align: left"> 복잡한 패턴 문제<br>문제 요구사항 정의는 함께 진행 후, ‘분해 및 패턴’ 과정은 팀 토론으로 정리 유도<br>①	(소개) 이진 검색 (Binary Searching)알고리즘|<div style="text-align: left">	팀 토론 (평가)|
|4|	7|<div style="text-align: left">추상화|<div style="text-align: left">‘추상화’ 개념<br> 간단한 추상화 문제<br>문제해결에 필요한 핵심만을 요약해내는 과정에 대한 이해<br>①	빅 데이터에서 문제에서 필요한 데이터만 추출 <br>②	컴퓨터 추상화<br>③	다양한 지도 추상화<br>④	픽토그램(Pictogram, 그림문자)<br>(실습) *** 을 위한 지도 추상화|<div style="text-align: left">이론실습 (평가)|
 |-|	8|-|<div style="text-align: left">복잡한 추상화 문제<br>문제를 준 후, 추상화된 결론을 토론으로 정리 유도<br>①	(다양한) 자동 판매기<br>②	(다양한) 맞추기 문제 (예: 숫자, 문자, 단어등등)<br>③	Google 자동 검색 원리 소개 	|팀 토론 (평가)|
|5|	9	|<div style="text-align: left">알고리즘	|<div style="text-align: left">	‘알고리즘’ 개념<br>간단한 알고리즘 문제<br>문제해결과정을 단계적, 반복적 절차로 표현하는 과정에 대한 이해<br>①	숫자 맞추기 게임<br> (실습) 자연어, 순서도 표현 방법 소개 및 활용	|<div style="text-align: left">이론실습 (평가) |
|-|	10|-|<div style="text-align: left">‘알고리즘’ 표현법<br>MIT scratch를 활용한 pseudo code 작성법 소개<br> ①	숫자 맞추기 게임 단어 맞추기 게임<br>②	자동 판매기 <br>(실습) MIT scratch를 활용한 순서도 및 pseudo code 작성<br>(실습) R기초 학습	|<div style="text-align: left">이론 실습 (평가)|
|6|	11|<div style="text-align: left">	문제1<br> 분할-점령|<div style="text-align: left">문제를 ‘분할-점령’ 할 때의 의미<br>①	숫자 정렬 (합병 정렬)<br>②	단어 정렬	|<div style="text-align: left">이론|
|-|	12|	-|<div style="text-align: left">	(실습) MIT scratch를 활용한 순서도 및 pseudo code 작성<br>(실습) R기초 학습	|<div style="text-align: left">실습 (평가)|
|7	|13|-|<div style="text-align: left">	(팀) * 벅스 신규 가맹점 위치 선정하기 – 문제 정의 및 설계|<div style="text-align: left">	팀 토론 (평가)|
|-|	14|-|<div style="text-align: left">	R을 활용한 알고리즘 완성 및 회고|<div style="text-align: left">	발표|
|8|	-	|<div style="text-align: left">중간고사 기간|-|-|
|9|	15|<div style="text-align: left">	문제 2 <br>탐욕적 기법	|문제를 ‘탐욕적’으로 해결할 때의 의미<br>①	거스름돈 문제<br>②	신도시 학교 배치 문제|<div style="text-align: left">	이론|
|-|	16|-|	(실습) R을 활용한 작업 스케줄링|	실습 (평가)|    
|10| 17 |-|<div style="text-align: left">	(팀) 비행기 조종사 스케줄링 혹은 가난한 지도<br> 제작자 – 문제 정의 및 설계	|<div style="text-align: left">팀 토론 (평가)|
|-|	18|-|<div style="text-align: left"> R을 활용한 알고리즘 완성 및 회고|<div style="text-align: left">	발표|
|11|19|<div style="text-align: left">	문제 3<br> 근사 알고리즘|<div style="text-align: left">	문제를 ‘근사 알고리즘’으로 해결할 때의 의미<br>①	통 채우기 문제<br>②	서울-부산 여행 경로 찾기 (최소시간)|<div style="text-align: left">	이론|
|-|	20|-|	|<div style="text-align: left">(실습) R을 활용한 작업 스케줄링	|<div style="text-align: left">실습 (평가)|
|12|21|	-|<div style="text-align: left">(팀) 지하철 경로 찾기 (최소시간, 최소환승) – 문제 정의 및 설계	|<div style="text-align: left">팀 토론 (평가)|
|-|	22|-|	R을 활용한 알고리즘 완성 및 회고|<div style="text-align: left">	발표|
|13|23|<div style="text-align: left">	팀프로젝트<br>‘회고’로 생각했던 문제를 자유 선정하여 진행|		문제 선정 및 요구사항 정의	|<div style="text-align: left">팀프로젝트 (평가)|
|-|	24|-|<div style="text-align: left">요구사항 정의 및 설계|-|	
|14|25|-|<div style="text-align: left">	설계|-|	
|-|	26|-|<div style="text-align: left"> R을 활용한 프로젝트 마무리 및 발표 정리|-|	
|15|27|<div style="text-align: left">	팀프로젝트 발표|-| 	
|-|	28|-|-|-|		
16|	-|<div style="text-align: left">	기말고사 기간|-|-|	


[참고] CT교육을 위한 영어버전 강의계획안의 예시는 어떻게 되고, 유명한 국외 대학들은 어떤 CT교육안을 가지고 교육을 수행하고 있을까요

<center> 
    
   Computational Thinking
[Comprehensive Course Syllabus Example]


 <div style="text-align: left">
    
 Course Description: 
 The course introduces students to the principles of computational thinking. Computational thinking is a way of solving problems, designing systems, developing algorithms, and understanding human behavior that draws on concepts fundamental to computer science. This course explores making use of different levels of abstraction, decomposition, modularization, and recursion to understand and solve problems more effectively. It uses mathematical concepts such as induction, to develop algorithms and produce more efficient, fair, elegant, and secure solutions. The object-oriented language, Python, will be used to demonstrate simple programming concepts. 
 
I N S T R U C T O R ( S ) : 
+	Name(s): Hayoung Oh
+	Email address(es): hyoh79@gmail.com
 
Meeting Days, Time and Room(s) 
 12:00 pm – 13:15 pm, on Mon. and Wed. days (509ho, Energy Center)
  
Text(s) / Materials: 
 There is no required text for this course. A number of online resources will be used extensively including MIT and other Univ. tutorials.  
  	 
Creativity and Innovation    
Students demonstrate creative thinking, construct knowledge, and develop innovative products and processes using technology. Students: 
a. apply existing knowledge to generate new ideas, products, or processes. 
b. create original works as a means of personal or group expression. 
c. use models and simulations to explore complex systems and issues. 
d. identify trends and forecast possibilities. 
 
Critical Thinking, Problem Solving, and Decision Making    
Students use critical thinking skills to plan and conduct research, manage projects, solve problems, and make informed decisions using appropriate digital tools and resources. Students: 
a.	identify and define authentic problems and significant questions for investigation. 
b.	plan and manage activities to develop a solution or complete a project. 
c.	collect and analyze data to identify solutions and/or make informed decisions. 
d.	use multiple processes and diverse perspectives to explore alternative solutions. 
  
Technology Operations and Concepts   Students demonstrate a sound understanding of technology concepts, systems, and operations. Students: 
a.	understand and use technology systems. 
b.	select and use applications effectively and productively. 
c.	troubleshoot systems and applications. 
d.	transfer current knowledge to learning of new technologies. 
 
 Instructional Design and Approach: 
Students will be asked to think about computational thinking. They will have to identify how they are using computational thinking in other disciplines and how would they use this skill to write algorithms. Experts, in the field of computational thinking, will give students first hand introduction to this topic via flipped learning. Problem solving skills will be emphasized through out the course. Students will then be introduced to Python, an easy to learn object oriented programming language, which can demonstrate the power of computing using computers. Students will have an opportunity to see their algorithms in action after they write simple code using Python.  
 
All students are expected to 
+be involved in class discussions and explorations, both large and small group. 
+ attend all the classes and be on time. 
+ complete all daily assignments, labs, and projects in a timely manner. 
+ take responsibility for learning certain basic skills and relationships. 
+ take responsibility for seeking additional help as it is needed. 
+ collaborate with each other and contribute to each other’s learning 
 
Assessment Practices, Procedures, and Processes: 
|   	  	 	      1st Quarter| 	          2nd Quarter| 
|            Exercises/Labs: 	                20% | 	            20% |
|            Participation/Organization: 	   5%|  	            5%| 
|            Quizzes/Exams: 	               45%|  	            45% |
|Projects/Assignments:             30%	|30%|

Weights of components of the semester grade: 
|-|-|-| 		
	|3rd Quarter|-| 	 	 	 	45% |
	|4th Quarter|-| 	 	 	 	45% |
|Final Project/exam/paper|-| 	 	10% |


Sequence of Topics and Activities:  
 
The following is subject to alteration at the discretion of the instructor.  

|Week| 	Topics Covered| 
|1 week,
2 week,
3 week|	About the course/go through syllabus. 
1)	What is Computational thinking (CT)? 
2)	Discussion of students’ understanding of CT 
3)	Examples and workbook submission
   +	Delicious Sandwich Robot Chef!
   +	Backseat code driver (i.e., Let your Kid Command your Driving)
   +	Password algorithm intro. and design
Designing solutions and developing algorithms Are they computable?|
|4 week,
5 week,
6 week,
7 week|	How do we Integrate computer science concepts into CT? 
1)	Use of computer science “mental tools” like     Abstraction, decomposition, modularization, and recursion to  develop algorithms and solutions  for simulating complex systems
2)	Examples and workbook submission
	+ Graph coloring based building habitats for a zoo
    + Map coloring theorem based poor mapmaker
    + Graph based social traveling
    + Graph based relationship analysis (i.e.,facebook)
      Designing solutions and developing algorithms Are they computable? 
|8 week|	Mid term|
|9 week,
10 week,
11 week| 	Study a given or creative problem (Example) 
+ Analyze and abstract the problem
1)	Abstraction: Modeling perspective 
2)	Abstraction: Engineering perspective
+	Design an effective solution to the problem 
+	Develop an algorithm for the solution 
Summarize the process 

Designing solutions and developing algorithms Are they computable?
+	Are there problems that have no algorithms? 
+	Are there functions that are not computable? 
+	Deciding what is computable and what is not.|
|12 week|
	How CT is implemented in various disciplines
+	Connecting computational thinking to the programming concepts 
+	Introduction to Python and its extensive libraries.  
+	Python tutorials and examples. Write a simple program|
|13 week|	Developing and implementing solution for a scientific problem|
|14 week| 	Demonstrating computational thinking using own project |
|15 week |	Project presentations|
|16 week|	Course wrap up, final projects/exam|



<center> 
    
   [Workbook example- Backseat code driver]


 <div style="text-align: left">
    
 
Q1) How long?
+	30minutes

Q2) What’s the Learning Outcome?
+	Computational Thinking
+	Critical Thinking
+	Decomposition
+	Categorization
+	Loops (i.e., Inspection and Iteration)
+	Sequencing
+	Pattern spotting
+	Bridge-building
+	Improvisation (즉흥곡), Creativity
+	Logical Reasoning

+	Conditional Statements (i.e., Conditionals)
+	Problem solving
+	Algorithm
+	Efficiency
+	Optimization 
+	Debugging
+	Experimentation
Q3) What age is it for?
	17-23 years old

Q4) What You’ll Need
+	You and your student
+	Car
+	A familiar-enough route that you’re driving
+	Enough free time that you can make some wrong turns

Q5) How to Play
+	Tell your student: 
  *	You must be the guide to get use to the destination. 
  *	Step1) 
    -	But they have only have 5 commands to use: Straight, Left, Right, Stop, Go. Try (while following traffic laws) to drive exactly as they command.
  *	Step2)
    -	Be careful the instructions and unexpected mobile vehicles.
  *	Step3)
    -	Challenge them to think through what they could do to improve their sequence of commands.
      +	The shortest route
      +	The automated driver
      +	Optimization according to the vehicle of unexpected direction change, traffic jam or vehicle accident


<center> 
    
   [MIT Syllabus example- CT]
![fig130](https://user-images.githubusercontent.com/40076487/75105322-17385c80-5655-11ea-9cad-a0decfb51c0d.png)
그림. 29. MIT대학의 컴퓨팅 사고 수업 계획안 예시
![fig131](https://user-images.githubusercontent.com/40076487/75105143-cc1e4980-5654-11ea-9384-bdb36f815612.png)
[Other Syllabus example- CT]
![fig132](https://user-images.githubusercontent.com/40076487/75105144-cd4f7680-5654-11ea-8c84-c11d18e48929.png)
[Other Syllabus example- CT]
![fig133](https://user-images.githubusercontent.com/40076487/75105145-cde80d00-5654-11ea-996d-2d4386dfc044.png)
그림. 30. 기타 국외 대학들의 컴퓨팅 사고 수업 계획안 예시
 <div style="text-align: left">
    
    
    
